window.CURRENT_INDICES=[{"title":"数据表单动作","link":"action-form","nodes":[]},{"title":"数据表格动作","link":"action-grid","nodes":[]},{"title":"数据详情动作","link":"action-show","nodes":[]},{"title":"模型树动作","link":"action-tree","nodes":[]},{"title":"动作基本使用","link":"action","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"开发者通过 Action 动作类可以非常方便的开发出一个含有特定功能的操作，可以非常方便的让用户与服务器产生交互。 例如，页面上需要一个按钮，用户点击之后可以向服务器发起请求，通过弹窗展示当前登录用户的信息，那么这个功能按钮就可以用 Action 来开发。"},{"h2":"示例","h3":"","h4":"","name":"示例-h2","content":"下面我们就开始开发一个用于查看登录用户信息的按钮："},{"h2":"示例","h3":"使用命令创建Action类","h4":"","name":"使用命令创建Action类-h3","content":"首先需要先创建 Action 类，运行命令  php artisan admin:action  运行成功之后会看到命令窗口出现如下信息，让开发者选择一个 Action 类的类型，这里我们输入 0 就行   Which type of action would you like to make?: [0] default [1] grid-batch [2] grid-row [3] grid-tool [4] form-tool [5] show-tool [6] tree-tool > 0 # 输入 0   接着输入 Action 类名称，这里需要输入 大驼峰 风格的英文字母   Please enter a name of action class: > ShowCurrentAdminUser   类名输入完成之后会出现以下信息让开发者输入类的命名空间，默认的命名空间是 App\\Admin\\Actions，这里我们直接按回车跳过就行了   Please enter the namespace of action class [App\\Admin\\Actions]: >   这样一个 Action 类就创建完成了，刚刚创建的类路径是 app/Admin/Actions/ShowCurrentAdminUser.php"},{"h2":"示例","h3":"使用","h4":"","name":"使用-h3","content":"修改 Action 类如下  <?php namespace App\\Admin\\Actions; use Dcat\\Admin\\Admin; use Dcat\\Admin\\Widgets\\Table; use Dcat\\Admin\\Actions\\Action; use Dcat\\Admin\\Actions\\Response; use Dcat\\Admin\\Models\\HasPermissions; use Illuminate\\Contracts\\Auth\\Authenticatable; use Illuminate\\Database\\Eloquent\\Model; use Illuminate\\Http\\Request; class ShowCurrentAdminUser extends Action { /** * 按钮标题 * * @var string */ protected $title = '个人信息'; /** * @var string */ protected $modalId = 'show-current-user'; /** * 处理当前动作的请求 * * @param Request $request * * @return Response */ public function handle(Request $request) { // 获取当前登录用户模型 $user = Admin::user(); // 这里我们用表格展示模型数据 $table = Table::make($user->toArray()); return $this->response() ->success('查询成功') ->html($table); } /** * 处理响应的HTML字符串，附加到弹窗节点中 * * @return string */ protected function handleHtmlResponse() { return <<<'JS' var $modal = $(target.data('target')); $modal.find('.modal-body').html(response.html) $modal.modal('show') JS; } /** * 设置HTML标签的属性 * * @return void */ protected function setupHtmlAttributes() { // 添加class $this->addHtmlClass('btn btn-primary'); // 保存弹窗的ID $this->setHtmlAttribute('data-target', '#'.$this->modalId); parent::setupHtmlAttributes(); } /** * 设置按钮的HTML，这里我们需要附加上弹窗的HTML * * @return string|void */ public function html() { // 按钮的html $html = parent::html(); return <<<HTML {$html} <div class=\"modal fade\" id=\"{$this->modalId}\" tabindex=\"-1\" role=\"dialog\"> <div class=\"modal-dialog modal-lg\" role=\"document\"> <div class=\"modal-content\"> <div class=\"modal-header\"> <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button> <h4 class=\"modal-title\">{$this->title()}</h4> </div> <div class=\"modal-body\"></div> </div> </div> </div> HTML; } /** * 确认信息，如果此方法返回不为空，则点击按钮之后会弹出确认框 * * @return string|void */ public function confirm() { } /** * 动作权限判断，返回false则表示无权限 * * @param Model|Authenticatable|HasPermissions|null $user * * @return bool */ protected function authorize($user): bool { return true; } /** * 通过这个方法可以设置动作发起请求时需要附带的参数 * * @return array */ protected function parameters() { return []; } }  修改完之后就可以开始使用了  <?php use App\\Admin\\Actions\\ShowCurrentAdminUser; class IndexController { public function index(Content $content) { return $content->body(ShowCurrentAdminUser::make()); } }  效果如下"},{"h2":"属性","h3":"","h4":"","name":"属性-h2","content":"Dcat\\Admin\\Actions\\Action 类可用属性说明   属性名 类型 默认值 描述 title string 标题 selectorPrefix public string .admin-action- 目标元素的Css选择器 method string POST 与服务器交互的请求方法 event string click 目标元素绑定的事件，默认为点击事件 disabled bool false 是否渲染动作元素，设置true则不渲染 usingHandler bool true 当此属性设置为false，则无论Action中是否包含handle方法都不会向服务器发起请求 "},{"h2":"方法","h3":"","h4":"","name":"方法-h2","content":"Dcat\\Admin\\Actions\\Action 类方法说明"},{"h2":"方法","h3":"make","h4":"","name":"make-h3","content":"此方法是一个静态方法，用于实例化动作类  $action = MyAction::make($param1, $param2...);"},{"h2":"方法","h3":"handle","h4":"","name":"handle-h3","content":"当Action类中包含此方法之时，目标元素会被绑定通过event属性设置的事件（默认为click）。如果事件被触发，则会向服务器发起请求，而handle方法则可以处理并响应此请求。   如果没有此方法，则目标元素不会被绑定事件。 "},{"h2":"方法","h3":"response","h4":"","name":"response-h3","content":"此方法用于获取Response对象，然后响应前端发起的请求，此方法仅在handle方法内有效。  <?php use Dcat\\Admin\\Actions\\Action; use Illuminate\\Http\\Request; class MyAction extends Action { public function handle(Request $request) { return $this->response()->success('成功！'); } } "},{"h2":"方法","h3":"response","h4":"展示成功信息","name":"展示成功信息-h4","content":"此方法接收一个string类型参数  $this->response()->success('成功！');"},{"h2":"方法","h3":"response","h4":"展示错误信息","name":"展示错误信息-h4","content":"此方法接收一个string类型参数  $this->response()->error('出错了！');"},{"h2":"方法","h3":"response","h4":"展示警告信息","name":"展示警告信息-h4","content":"此方法接收一个string类型参数  $this->response()->warning('警告');"},{"h2":"方法","h3":"response","h4":"跳转","name":"跳转-h4","content":"此方法接收一个string类型参数，可以与success、error、warning等方法同时使用  $this->response()->redirect('auth/users');"},{"h2":"方法","h3":"response","h4":"跳转(location)","name":"跳转(location)-h4","content":"此方法接收一个string类型参数  $this->response()->location('auth/users');"},{"h2":"方法","h3":"response","h4":"刷新当前页面","name":"刷新当前页面-h4","content":"此方法可以与success、error、warning等方法同时使用  $this->response()->refresh();"},{"h2":"方法","h3":"response","h4":"下载","name":"下载-h4","content":"此方法接收一个string类型参数  $this->response()->download('auth/users?_export_=1');"},{"h2":"方法","h3":"response","h4":"返回HTML","name":"返回HTML-h4","content":"此方法可接收一个string、Renderable、Htmlable类型参数，可以与success、error、warning等方法同时使用   响应的HTML字符默认会被置入动作按钮元素上，如果需要自己控制，则覆写Action::handleHtmlResponse方法即可。   $this->response()->html('<a>a标签</a>'); $this->response()->html(view('...'));"},{"h2":"方法","h3":"response","h4":"执行JS代码","name":"执行JS代码-h4","content":"此方法接收一个string类型参数，可以与success、error、warning等方法同时使用  $this->response()->script( <<<JS console.log('response', response, target); JS );"},{"h2":"方法","h3":"parameters","h4":"","name":"parameters-h3","content":"通过这个方法可以设置动作发起请求时需要附带的参数  <?php use Dcat\\Admin\\Actions\\Action; use Illuminate\\Http\\Request; class MyAction extends Action { public function handle(Request $request) { // 接收参数 $key1 = $request->get('key1'); $key2 = $request->get('key2'); return $this->response()->success('成功！'); } public function parameters() { return [ 'key1' => 'value1', 'key2' => 'value2', ]; } } "},{"h2":"方法","h3":"confirm","h4":"","name":"confirm-h3","content":"设置确认信息，此方法要求返回一个string类型参数。  当此方法返回值不为空时会加入确认窗功能，当事件被触发时自动弹出确认框，点击确认后才会进行下一步操作。  public function confirm() { return '你确定要删除此行内容吗？'; }"},{"h2":"方法","h3":"actionScript","h4":"","name":"actionScript-h3","content":"设置动作执行的前置js代码，当按钮绑定的事件被触发后，发起请求之前会执行通过此方法设置的js代码。  protected function actionScript() { return <<<JS console.log('发起请求之前', target); // return 在这里return可以终止执行后面的操作 JS }"},{"h2":"方法","h3":"buildRequestScript","h4":"","name":"buildRequestScript-h3","content":"生成与服务器交互的js代码，有需要可以覆写此方法"},{"h2":"方法","h3":"handleHtmlResponse","h4":"","name":"handleHtmlResponse-h3","content":"处理服务器响应的HTML代码  protected function handleHtmlResponse() { return <<<'JS' console.log('打印HTML代码', response.html); // 附加到页面中 $('xxx').html(response.html) JS; }"},{"h2":"方法","h3":"authorize","h4":"","name":"authorize-h3","content":"此方法用于判断登录用户的操作权限，默认返回true  protected function authorize($user): bool { return $user->can('do-action'); }"},{"h2":"方法","h3":"failedAuthorization","h4":"","name":"failedAuthorization-h3","content":"此方法用于设置鉴权失败的响应内容，如果需要则可覆写此方法  public function failedAuthorization() { return $this->response()->error(__('admin.deny')); }"},{"h2":"方法","h3":"disable","h4":"","name":"disable-h3","content":"设置显示或隐藏此动作  // 隐藏 MyAction::make()->disable(); // 显示 MyAction::make()->disable(true);"},{"h2":"方法","h3":"allowed","h4":"","name":"allowed-h3","content":"判断动作是否允许显示  if (MyAction::make()->allowed()) { ... }"},{"h2":"方法","h3":"setKey","h4":"","name":"setKey-h3","content":"设置数据主键  $id = ...; MyAction::make()->setKey($id);"},{"h2":"方法","h3":"key","h4":"","name":"key-h3","content":"获取数据主键，此方法在handle方法内也同样可用  <?php use Dcat\\Admin\\Actions\\Action; use Illuminate\\Http\\Request; class MyAction extends Action { public function handle(Request $request) { $id = $this->key(); ... return $this->response()->success('成功！'); } public function title() { return \"标题 {$this->key()}\"; } }"},{"h2":"方法","h3":"elementClass","h4":"","name":"elementClass-h3","content":"获取动作目标元素（按钮）的class  $class = MyAction::make()->elementClass();"},{"h2":"方法","h3":"selector","h4":"","name":"selector-h3","content":"获取动作目标元素（按钮）的CSS选择器  $selector = MyAction::make()->selector(); Admin::script( <<<JS $('$selector').click(...); JS );"},{"h2":"方法","h3":"addHtmlClass","h4":"","name":"addHtmlClass-h3","content":"追加获取动作目标元素（按钮）的class  MyAction::make()->addHtmlClass('btn btn-primary'); MyAction::make()->addHtmlClass(['btn', 'btn-primary']);"},{"h2":"方法","h3":"html","h4":"","name":"html-h3","content":"此方法用于设置动作目标元素的HTML代码，如有需要可以覆写  protected function html() { return <<<HTML <a {$this->formatHtmlAttributes()}>{$this->title()}</a> HTML; }"},{"h2":"方法","h3":"addScript","h4":"","name":"addScript-h3","content":"此方法用于在render方法执行完毕之前添加JS代码  protected function addScript() { return <<<JS console.log('...') JS; }"},{"h2":"方法","h3":"setHtmlAttribute","h4":"","name":"setHtmlAttribute-h3","content":"设置目标元素的HTML标签属性  MyAction::make()->setHtmlAttribute('name', $value); MyAction::make()->setHtmlAttribute(['name' => $value]); "},{"h2":"方法","h3":"setupHtmlAttributes","h4":"","name":"setupHtmlAttributes-h3","content":"此方法用于在render方法执行完毕之前给目标元素设置属性  protected function setupHtmlAttributes() { $this->setHtmlAttribute('data-target', 'xxx'); // 覆写时别忘了调用父级方法 parent::setupHtmlAttributes(); }"}]},{"title":"静态资源加载","link":"assets","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"Dcat Admin修改了pjax源码，增加了js脚本按需加载的功能，开发者只需在控制器action中引入需要用到的js组件即可，而无需在项目初始化时引入所有的js组件。"},{"h2":"","h3":"加载js脚本","h4":"","name":"加载js脚本-h3","content":"Admin::js方法可以引入js脚本，使用如下：  class UserController extend Controller { public function index() { Admin::js('/assets/js/index.js'); Admin::js([ '/assets/js/index2.js' ]); } }"},{"h2":"","h3":"加载css脚本","h4":"","name":"加载css脚本-h3","content":"Admin::css方法可以引入css脚本，使用如下：  class UserController extend Controller { public function index() { Admin::css('/assets/css/index.css'); Admin::css([ '/assets/css/index2.css' ]); } }"},{"h2":"","h3":"动态添加js代码","h4":"","name":"动态添加js代码-h3","content":"Admin::script方法可以动态添加js代码，使用如下：   public function index() { Admin::script( <<<JS console.log('Hello world!'); JS ); }"},{"h2":"","h3":"动态添加css代码","h4":"","name":"动态添加css代码-h3","content":"Admin::style方法可以动态添加css代码，使用如下：   public function index() { Admin::style( <<<CSS body { color: #333; } CSS ); }"},{"h2":"","h3":"在模板中引入静态资源","h4":"","name":"在模板中引入静态资源-h3","content":"在模板中手动引入静态资源需要使用admin_asset函数：  // 引入css <link rel=\"stylesheet\" href=\"{{ admin_asset(\"vendor/dcat-admin/dcat-admin/main.min.css\") }}\"> // 引入js <script src=\"{{ admin_asset('vendor/dcat-admin/dcat-admin/main.min.js')}}\"></script>"},{"h2":"","h3":"在模板中添加js代码","h4":"","name":"在模板中添加js代码-h3","content":"要在模板中添加的js代码需要放在LA.ready方法内执行，这样才能保证你的js代码在所有js脚本加载完成之后执行。  <script> LA.ready(function () { console.log('所有js都加载完成了'); }); </script>"}]},{"title":"Change log","link":"change-log","nodes":[]},{"title":"页面内容和布局","link":"content-layout","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"Dcat Admin的布局可参考后台首页的布局文件app/Admin/Controllers/HomeController.php的index()方法。 Dcat\\Admin\\Layout\\Content类用来实现内容区的布局。Content::body($content)方法用来添加页面内容。 一个简单的后台页面代码如下： public function index() { return Admin::content(function (Content $content) { // 选填 $content->header('填写页面头标题'); // 选填 $content->description('填写页面描述小标题'); // 添加面包屑导航 $content->breadcrumb( ['text' => '首页', 'url' => '/admin'], ['text' => '用户管理', 'url' => '/admin/users'], ['text' => '编辑用户'] ); // 填充页面body部分，这里可以填入任何可被渲染的对象 $content->body('hello world'); }); } 其中 $content->body() 方法是 $content->row() 的别名方法，可以接受任何可字符串化的对象作为参数，可以是字符串、数字、包含了__toString方法的对象，实现了Renderable、Htmlable接口的对象，包括laravel的视图。"},{"h2":"","h3":"布局","h4":"","name":"布局-h3","content":"dcat-admin的布局使用bootstrap的栅格系统，每行的长度是12，下面是几个简单的示例：  添加一行内容:  $content->row('hello') --------------------------------- |hello | | | | | | | | | | | ---------------------------------   行内添加多列：  $content->row(function(Row $row) { $row->column(4, 'foo'); $row->column(4, 'bar'); $row->column(4, 'baz'); }); ---------------------------------- |foo |bar |baz | | | | | | | | | | | | | | | | | | | | | ---------------------------------- $content->row(function(Row $row) { $row->column(4, 'foo'); $row->column(8, 'bar'); }); ---------------------------------- |foo |bar | | | | | | | | | | | | | | | | ----------------------------------   列中添加行：  $content->row(function (Row $row) { $row->column(4, 'xxx'); $row->column(8, function (Column $column) { $column->row('111'); $column->row('222'); $column->row('333'); }); }); ---------------------------------- |xxx |111 | | |---------------------| | |222 | | |---------------------| | |333 | | | | ----------------------------------   列中添加行, 行内再添加列：  $content->row(function (Row $row) { $row->column(4, 'xxx'); $row->column(8, function (Column $column) { $column->row('111'); $column->row('222'); $column->row(function(Row $row) { $row->column(6, '444'); $row->column(6, '555'); }); }); }); ---------------------------------- |xxx |111 | | |---------------------| | |222 | | |---------------------| | |444 |555 | | | | | ----------------------------------"},{"h2":"","h3":"事件","h4":"","name":"事件-h3","content":"系统会在Dcat\\Admin\\Layout\\Content类被实例化时和render()方法被调用时触发以下两个事件，开发者可以在这两个事件中改变或添加一些行为。"},{"h2":"","h3":"事件","h4":"resolving","name":"resolving-h4","content":"通过Content::resolving方法设置的回调函数会在Dcat\\Admin\\Layout\\Content类被实例化时触发；  use Dcat\\Admin\\Layout\\Content; Content::resolving(function (Content $content) { $content->setView('app.admin.content'); });"},{"h2":"","h3":"事件","h4":"composing","name":"composing-h4","content":"通过Content::composing方法设置的回调函数会在Dcat\\Admin\\Layout\\Content::render方法被调用时触发；  use Dcat\\Admin\\Layout\\Content; Content::composing(function (Content $content) { $content->setView('app.admin.content'); });"},{"h2":"","h3":"事件","h4":"composed","name":"composed-h4","content":"通过Content::composed方法设置的回调函数会在所有通过Content::row或Content::body方法设置的内容都构建完毕后触发。  use Dcat\\Admin\\Layout\\Content; class IndexController { public function index(Content $content) { Content::composed(function (Content $content) { // Grid已执行render方法 }); return $content->body(function ($row) { $grid = new Grid(...); ... $row->column(12, $grid); }); } }"}]},{"title":"CSS Class","link":"css","nodes":[]},{"title":"自定义登陆","link":"custom-authentication","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"如果不使用dcat-admin内置的认证登陆逻辑，可以参考下面的方式自定义登陆认证逻辑 首先要先定义一个user provider，用来获取用户身份, 比如app/Providers/CustomUserProvider.php： <?php namespace App\\Providers; use Illuminate\\Contracts\\Auth\\Authenticatable; use Illuminate\\Contracts\\Auth\\UserProvider; class CustomUserProvider implements UserProvider { public function retrieveById($identifier) {} public function retrieveByToken($identifier, $token) {} public function updateRememberToken(Authenticatable $user, $token) {} public function retrieveByCredentials(array $credentials) { // 用$credentials里面的用户名密码去获取用户信息，然后返回Illuminate\\Contracts\\Auth\\Authenticatable对象 } public function validateCredentials(Authenticatable $user, array $credentials) { // 用$credentials里面的用户名密码校验用户，返回true或false } } 在方法retrieveByCredentials和validateCredentials中, 传入的$credentials就是登陆页面提交的用户名和密码数组，然后你可以使用$credentials去实现自己的登陆逻辑 Interface Illuminate\\Contracts\\Auth\\Authenticatable的定义如下： <?php namespace Illuminate\\Contracts\\Auth; interface Authenticatable { public function getAuthIdentifierName(); public function getAuthIdentifier(); public function getAuthPassword(); public function getRememberToken(); public function setRememberToken($value); public function getRememberTokenName(); } 上面interface每个方法的解释参考adding-custom-user-providers 定义好了User provider之后，打开app/Providers/AuthServiceProvider.php注册它： <?php namespace App\\Providers; use Illuminate\\Support\\Facades\\Auth; use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider; class AuthServiceProvider extends ServiceProvider { /** * Register any application authentication / authorization services. * * @return void */ public function boot() { $this->registerPolicies(); Auth::provider('custom', function ($app, array $config) { // Return an instance of Illuminate\\Contracts\\Auth\\UserProvider... return new CustomUserProvider(); }); } } 最后修改一下配置,打开config/admin.php，找到auth部分修改: 'auth' => [ 'guards' => [ 'admin' => [ 'driver' => 'session', 'provider' => 'admin', ] ], // 修改下面 'providers' => [ 'admin' => [ 'driver' => 'custom', ] ], ], 这样就完成了自定义登陆认证的逻辑，自定义登陆算是laravel中比较复杂的部分，需要开发者有耐心的一步步调试完成。"}]},{"title":"自定义图表","link":"custom-chart","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"dcat-admin 1.5已经移除了所有的图表组件，如果要在页面中加入图表组件，可以参考下面的流程 用chartjs举例，首先要下载chartjs，放到public目录下面，比如放在public/vendor/chartjs目录 然后在app/Admin/bootstrap.php引入组件： use Dcat\\Admin\\Facades\\Admin; Admin::js('/vendor/chartjs/dist/Chart.min.js'); 新建视图文件 resources/views/admin/charts/bar.blade.php <canvas id=\"myChart\" width=\"400\" height=\"400\"></canvas> <script> $(function () { var ctx = document.getElementById(\"myChart\").getContext('2d'); var myChart = new Chart(ctx, { type: 'bar', data: { labels: [\"Red\", \"Blue\", \"Yellow\", \"Green\", \"Purple\", \"Orange\"], datasets: [{ label: '# of Votes', data: [12, 19, 3, 5, 2, 3], backgroundColor: [ 'rgba(255, 99, 132, 0.2)', 'rgba(54, 162, 235, 0.2)', 'rgba(255, 206, 86, 0.2)', 'rgba(75, 192, 192, 0.2)', 'rgba(153, 102, 255, 0.2)', 'rgba(255, 159, 64, 0.2)' ], borderColor: [ 'rgba(255,99,132,1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)', 'rgba(75, 192, 192, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)' ], borderWidth: 1 }] }, options: { scales: { yAxes: [{ ticks: { beginAtZero:true } }] } } }); }); </script> 然后就可以在页面的任何地方引入这个图表视图了： public function index() { return Admin::content(function (Content $content) { $content->header('chart'); $content->description('.....'); $content->body(view('admin.charts.bar')); }); } 按照上面的方式可以引入任意图表库，多图表页面的布局，参考视图布局"}]},{"title":"自定义头部导航条","link":"custom-navbar","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"如果要在顶部导航条上添加html元素, 打开app/Admin/bootstrap.php： use Dcat\\Admin\\Facades\\Admin; Admin::navbar(function (\\Dcat\\Admin\\Widgets\\Navbar $navbar) { $navbar->left('html...'); $navbar->right('html...'); }); left和right方法分别用来在头部的左右两边添加内容，方法参数可以是任何可以渲染的对象(实现了Htmlable、Renderable接口或者包含__toString()方法的对象)或字符串"},{"h2":"左侧添加示例","h3":"","h4":"","name":"左侧添加示例-h2","content":"举个例子，比如在左边添加一个搜索条，先创建一个blade视图resources/views/search-bar.blade.php：  <style> .search-form { width: 250px; margin: 10px 0 0 20px; border-radius: 3px; float: left; } .search-form input[type=\"text\"] { color: #666; border: 0; } .search-form .btn { color: #999; background-color: #fff; border: 0; } </style> <form action=\"/admin/posts\" method=\"get\" class=\"search-form\" pjax-container> <div class=\"input-group input-group-sm \"> <input type=\"text\" name=\"title\" class=\"form-control\" placeholder=\"Search...\"> <span class=\"input-group-btn\"> <button type=\"submit\" name=\"search\" id=\"search-btn\" class=\"btn btn-flat\"><i class=\"fa fa-search\"></i></button> </span> </div> </form>  然后加入头部导航条：  $navbar->left(view('search-bar'));"},{"h2":"右侧添加示例","h3":"","h4":"","name":"右侧添加示例-h2","content":"导航右侧只能添加<li>标签, 比如要添加一些提示图标，新建渲染对象app/Admin/Extensions/Nav/Links.php  <?php namespace App\\Admin\\Extensions\\Nav; class Links { public function __toString() { return <<<HTML <li> <a href=\"#\"> <i class=\"fa fa-envelope-o\"></i> <span class=\"label label-success\">4</span> </a> </li> <li> <a href=\"#\"> <i class=\"fa fa-bell-o\"></i> <span class=\"label label-warning\">7</span> </a> </li> <li> <a href=\"#\"> <i class=\"fa fa-flag-o\"></i> <span class=\"label label-danger\">9</span> </a> </li> HTML; } }  然后加入头部导航条：  $navbar->right(new \\App\\Admin\\Extensions\\Nav\\Links());  或者用下面的html加入下拉菜单：  <li class=\"dropdown notifications-menu\"> <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\" aria-expanded=\"false\"> <i class=\"fa fa-bell-o\"></i> <span class=\"label label-warning\">10</span> </a> <ul class=\"dropdown-menu\"> <li class=\"header\">You have 10 notifications</li> <li> <!-- inner menu: contains the actual data --> <ul class=\"menu\"> <li> <a href=\"#\"> <i class=\"fa fa-users text-aqua\"></i> 5 new members joined today </a> </li> <li> <a href=\"#\"> <i class=\"fa fa-warning text-yellow\"></i> Very long description here that may not fit into the page and may cause design problems </a> </li> <li> <a href=\"#\"> <i class=\"fa fa-users text-red\"></i> 5 new members joined </a> </li> <li> <a href=\"#\"> <i class=\"fa fa-shopping-cart text-green\"></i> 25 sales made </a> </li> <li> <a href=\"#\"> <i class=\"fa fa-user text-red\"></i> You changed your username </a> </li> </ul> </li> <li class=\"footer\"><a href=\"#\">View all</a></li> </ul> </li>  更多的组件可以参考Bootstrap"}]},{"title":"开发扩展","link":"extend","nodes":[{"h2":"开始","h3":"","h4":"","name":"pre","content":"Dcat Admin支持安装扩展工具来帮助丰富你的后台功能。   需要注意的是，Laravel Admin原有的扩展无法直接在Dcat Admin中使用，但大部分扩展只需要做一些微小的调整就可以正常使用了，有兴趣的同学可以自行移植。   如果大家在使用的过程中有在Dcat Admin的基础上添加一些自己的功能或者组件，不妨做成一个Dcat Admin扩展，这样可以给其它Dcat Admin使用者提供帮助，并且在其它人的使用反馈中的提升扩展的质量。  这篇文档将会以开发一个干货集中营扩展为例，一步一步的开发一个扩展，并且发布给他人使用，最终的效果参考[Demo]()。"},{"h2":"创建composer包","h3":"","h4":"","name":"composer","content":"Dcat Admin的包将会用composer安装，所以先要创建一个composer包，可以用内置的admin:extend命令来生成一个扩展的骨架。  运行命令的时候，可能会提示输入一个目录来存放你的扩展文件，你可以在config/admin.php里面增加一个配置'extension_dir' => admin_path('Extensions')，这样扩展文件将会存放在app/Admin/Extensions目录下,当然你也可以放在任何其它目录。  php artisan admin:extend dcat-admin-extension/gank --namespace=Dcat\\\\Admin\\\\Extension\\\\Gank  其中dcat-admin-extension/gank是包名，namespace选项是这个包使用的顶级命名空间，运行这个命令之后, 将会在在config/admin.php中设置的扩展目录中生成目录dcat-admin-extension/gank和下面的文件结构：  ├── LICENSE ├── README.md ├── composer.json ├── bootstrap.php ├── database │ ├── migrations │ └── seeds ├── resources │ ├── assets │ └── views │ └── index.blade.php ├── routes │ └── web.php └── src ├── Gank.php ├── GankServiceProvider.php └── Http └── Controllers └── GankController.php  bootstrap.php用于注册扩展，此文件的代码不需要做任何修改；resources用来放置视图文件和静态资源文件；src主要用来放置逻辑代码； routes/web.php用来存放这个扩展的路由设置，database用来放置数据库迁移文件和数据seeders。"},{"h2":"功能开发","h3":"","h4":"","name":"dev","content":"这个扩展的功能主要用来展示gank.io接口的内容，集成进Dcat Admin中，它将会有一个路由和一个控制器，没有数据库文件、模板和静态资源文件，我们可以将没有用到的文件或目录清理掉，清理之后的目录文件为：  ├── LICENSE ├── README.md ├── composer.json ├── bootstrap.php ├── routes │ └── web.php └── src ├── Gank.php ├── GankServiceProvider.php └── Http └── Controllers └── GankController.php  生成完扩展框架之后，你可能需要一边调试一边开发，所以可以参考下面的本地安装，先把扩展安装进系统中，继续开发"},{"h2":"功能开发","h3":"添加路由","h4":"","name":"route","content":"首先添加一个路由，在routes/web.php中已经自动生成好了一个路由配置  <?php use Dcat\\Admin\\Extension\\Gank\\Http\\Controllers; Route::get('gank', Controllers\\GankController::class.'@index');  访问路径http://localhost:8000/admin/gank，将会由Dcat\\Admin\\Extension\\Gank\\Http\\Controllers\\GankController控制器的index方法来处理这个请求。"},{"h2":"功能开发","h3":"设置扩展属性","h4":"","name":"attrs","content":"src/Gank.php作为扩展类，用来设置扩展的属性  <?php namespace Dcat\\Admin\\Extension\\Gank; use Dcat\\Admin\\Extension; class Gank extends Extension { // 扩展别名，用于在配置文件中获取配置信息 const NAME = 'gank'; // service provider类名，这个用自动生成的就行，不需要改 public $serviceProvider = GankServiceProvider::class; // 静态资源目录，如果不需要静态资源可用删除掉 // public $assets = __DIR__.'/../resources/assets'; // composer配置文件路径，用默认的即可 public $composerJson = __DIR__.'/../composer.json'; // 自定义属性 public static $categoryColorsMap = [ 'App' => 'var(--purple)', '前端' => 'var(--primary)', '拓展资源' => 'var(--primary-dark)', '瞎推荐' => 'var(--blue)', '福利' => 'var(--danger)', 'Android' => 'var(--purple-dark)', 'iOS' => 'var(--info)', '休息视频' => 'var(--warning)', ]; }   这个文件用来设置这个扩展的一些属性，$name是这个扩展的别名，如果这个扩展有视图文件需要渲染，则必须指定这个扩展的$views属性，同样如果有静态资源文件需要发布，则必须设置$assets属性， 如果需要在左侧边栏增加一项菜单按钮，设置$menu属性，可以根据需要去掉不必要的属性。  然后打开src/GankServiceProvider.php，这个ServiceProvider将会在启用扩展的时候运行（不需要开发者自己添加），用来将这个扩展的一些服务注册进系统中。"},{"h2":"功能开发","h3":"加载视图","h4":"","name":"loadview","content":"如果这个扩展需要加载视图文件，在src/GankServiceProvider.php的boot方法中加入以下的代码：  $extension = Gank::make(); if ($extension->views) { $this->loadViewsFrom($extension->views, 'gank'); }  loadViewsFrom方法的的第一个参数为在扩展类src/Gank.php中设置的视图属性，第二个参数是视图文件目录的命名空间，设置为gank之后，在控制器中用view('gank::index')来加载resources/views目录下的视图文件。"},{"h2":"功能开发","h3":"引入静态资源","h4":"","name":"loadassets","content":"如果你的项目中有静态资源文件需要引入，先把文件放在resources/assets目录中，比如放入resources/assets/foo.js和resources/assets/bar.css这两个文件。  接着在扩展类src/Gank.php中设置$assets属性即可：  public $assets = __DIR__.'/../resources/assets';  安装完成之后，文件将会复制到public/vendor/dcat-admin-extensions/gank目录中。  我们需要在Dcat Admin启动的时候在页面里引入这两个文件，需要在src/GankServiceProvider.php的boot方法加入下面的代码：  use use Encore\\Admin\\Admin; ... Admin::booting(function () { Admin::js('vendor/dcat-admin-extensions/gank/phpinfo/foo.js'); Admin::css('vendor/dcat-admin-extensions/gank/phpinfo/bar.css'); });  这样就完成了静态资源的引入，在gank这个扩展中，由于没有静态资源需要引入，所以可以忽略掉这一步。"},{"h2":"功能开发","h3":"添加菜单","h4":"","name":"addmenu","content":"添加菜单的方式有两种：   在src/Gank.php设置$menu属性，这种方式是把菜单写入到菜单表中，用户更易于控制 使用Admin::menu接口通过数组的方式添加菜单，这种方式更加方便，并且支持添加多级菜单   这里使用的是第二种方式添加菜单，在src/GankServiceProvider.php的boot方法加入下面的代码：  Admin::menu()->add([ [ 'id' => 1, 'title' => '干货集中营', 'icon' => ' fa-newspaper-o', 'uri' => 'gank', 'parent_id' => 0, 'permission_id' => 'gank', // 绑定权限 'roles' => [['slug' => 'gank']], // 绑定角色 ], [ 'id' => 2, 'title' => '所有干货', 'icon' => 'fa-smile-o', 'uri' => 'gank', 'parent_id' => 1, 'permission_id' => 'gank', // 绑定权限 'roles' => [['slug' => 'gank']], // 绑定角色 ], ]);  最终的src/GankServiceProvider.php代码如下：  <?php namespace Dcat\\Admin\\Extension\\Gank; use Dcat\\Admin\\Admin; use Illuminate\\Support\\ServiceProvider; class GankServiceProvider extends ServiceProvider { /** * {@inheritdoc} */ public function boot() { $extension = Gank::make(); if ($extension->views) { $this->loadViewsFrom($extension->views, 'gank'); } if ($extension->lang) { $this->loadTranslationsFrom($extension->lang, 'gank'); } if ($extension->migrations) { $this->loadMigrationsFrom($extension->migrations); } $this->app->booted(function () use ($extension) { $extension->routes(__DIR__.'/../routes/web.php'); }); // 添加菜单 $this->registerMenus(); } protected function registerMenus() { Admin::menu()->add([ [ 'id' => 1, 'title' => '干货集中营', 'icon' => ' fa-newspaper-o', 'uri' => 'gank', 'parent_id' => 0, 'permission_id' => 'gank', // 绑定权限 'roles' => [['slug' => 'gank']], // 绑定角色 ], [ 'id' => 2, 'title' => '所有干货', 'icon' => 'fa-smile-o', 'uri' => 'gank', 'parent_id' => 1, 'permission_id' => 'gank', // 绑定权限 'roles' => [['slug' => 'gank']], // 绑定角色 ], ]); } }"},{"h2":"添加自定义安装逻辑","h3":"","h4":"","name":"importcode","content":"如果你想在导入扩展时执行一些自定义逻辑，可以在src/Gank.php中添加以下代码：   注意请保证重复执行导入命令不会报错   ... public function import(Command $command) { parent::import($command); // TODO: Change the autogenerated stub // 在这里写入你的导入逻辑 $command->info('导入成功'); } "},{"h2":"代码逻辑开发","h3":"","h4":"","name":"code","content":"这个扩展主要是调用[gank.io]()提供的接口，再把数据展示出来。  我们需要新增一个数据仓库文件用于获取[gank.io]()的数据，创建文件src/Repositories/Ganks.php：  <?php namespace Dcat\\Admin\\Extension\\Gank\\Repositories; use Dcat\\Admin\\Grid; use Dcat\\Admin\\Repositories\\Repository; use Illuminate\\Pagination\\LengthAwarePaginator; use Illuminate\\Support\\Collection; class Ganks extends Repository { protected $api = 'http://gank.io/api/data/{category}/{limit}/{page}'; protected $searchApi = 'http://gank.io/api/search/query/{key}/category/{category}/count/{limit}/page/{page}'; /** * 查询表格数据 * * @param Grid\\Model $model * @return Collection */ public function get(Grid\\Model $model) { $currentPage = $model->getCurrentPage(); $perPage = $model->getPerPage(); // 获取筛选参数 $category = $model->getFilter()->input(Grid\\Filter\\Scope::QUERY_NAME, 'all'); $keyword = trim($model->getFilter()->input('keyword')); $api = $keyword ? $this->searchApi : $this->api; $client = new \\GuzzleHttp\\Client(); $response = $client->get(str_replace( ['{category}', '{limit}', '{page}', '{key}'], [$category, $perPage, $currentPage, $keyword], $api )); $data = collect( json_decode((string)$response->getBody(), true)['results'] ?? [] ); $total = $keyword ? 400 : ($category == 'all' ? 1000 : 500); $paginator = new LengthAwarePaginator( $data, $category == '福利' ? 680 : $total, $perPage, // 传入每页显示行数 $currentPage // 传入当前页码 ); $paginator->setPath(\\url()->current()); return $paginator; } public function getKeyName() { return '_id'; } }  修改控制器代码如下：  <?php namespace Dcat\\Admin\\Extension\\Gank\\Http\\Controllers; use Dcat\\Admin\\Extension\\Gank\\Gank; use Dcat\\Admin\\Extension\\Gank\\Repositories\\Ganks; use Dcat\\Admin\\Grid; use Dcat\\Admin\\Layout\\Content; use Dcat\\Admin\\Layout\\Row; use Illuminate\\Routing\\Controller; use Dcat\\Admin\\Widgets\\Navbar; class GankController extends Controller { public function index(Content $content) { $grid = $this->grid(); $grid->disableFilter(); $grid->getFilter() ->withoutInputBorder() ->expand() ->resetPosition() ->hiddenResetButtonText(); return $content ->header('所有干货') ->description('每日分享妹子图 和 技术干货') ->body($grid->getFilter()) ->body(function (Row $row) { $items = array_keys(Gank::$categoryColorsMap); array_unshift($items, '全部'); $navbar = Navbar::make('#', array_combine($items, $items)) ->checked(request(Grid\\Filter\\Scope::QUERY_NAME, '全部')) ->click() ->map(function ($v) { if ($v == '全部') { $url = '?'; } else { $url = '?'.Grid\\Filter\\Scope::QUERY_NAME.'='.$v; } return \"<a href='$url'>$v</a>\"; }) ->style('max-width:705px'); $row->column(7, $navbar); }) ->body($grid); } protected function grid() { $this->define(); $grid = new Grid(new Ganks); $grid->number(); $grid->desc('描述')->width('300px'); $grid->images('图片')->image(150); $grid->type('类别'); $grid->who('作者')->label(); $grid->publishedAt('发布于'); $grid->disableActions(); $grid->disableBatchDelete(); $grid->disableExport(); $grid->disableCreateButton(); $grid->disableFilterButton(); $grid->disableQuickCreateButton(); $grid->perPages([]); return $grid->filter(function (Grid\\Filter $filter) { $category = $filter->input(Grid\\Filter\\Scope::QUERY_NAME, '全部'); if ($category != '福利') { $filter->like('keyword', ucfirst($category))->width('300px')->placeholder('请输入'); } }); } protected function define() { Grid\\Column::define('desc', function ($v) { if ($this->type == '福利') { $width = '150'; $height = '200'; return \"<img data-init='preview' src='{$this->url}' style='max-width:{$width}px;max-height:{$height}px;cursor:pointer' class='img img-thumbnail' />\"; } return sprintf('<a href=\"%s\" target=\"_blank\">%s</a>', $this->url, $v); }); Grid\\Column::define('publishedAt', function ($v) { return date('Y-m-d', strtotime($v)); }); Grid\\Column::define('datetime', function ($v) { return date('Y-m-d H:i:s', strtotime($v)); }); Grid\\Column::define('type', function ($v) { $map = Gank::$categoryColorsMap; return \"<span class='label' style='background:{$map[$v]}'>$v</span>\"; }); } }  这样一个完整的扩展就开发完成了。"},{"h2":"修改 composer.json & README.md","h3":"","h4":"","name":"updatejson","content":"代码部分完成之后，需要修改composer.json里面的内容，将description、keywords、license、authors等内容替换为你的信息，然后不要忘记完善README.md，补充使用文档等相关信息。"},{"h2":"安装","h3":"","h4":"","name":"install","content":"完成了扩展开发之后，根据情况可以用下面的的方式安装你的扩展"},{"h2":"安装","h3":"本地安装","h4":"","name":"local","content":"在开发的过程中，一般需要一边调试一边开发，所以先按照下面的方式进行本地安装  打开你的项目中composer.json文件，在加入下面的配置  \"repositories\": [ { \"type\": \"path\", \"url\": \"app/Admin/Extensions/dcat-admin-extensions/gank\" } ]  然后运行composer require dcat-admin-extensions/gank完成安装，如果有静态文件需要发布，运行下面的命令"},{"h2":"安装","h3":"远程安装","h4":"","name":"remote","content":"如果开发完成之后，希望开源出来给大家使用，按照下面的步骤进行"},{"h2":"安装","h3":"远程安装","h4":"上传到Github","name":"github","content":"先登录你的Github，创建一个仓库，然后按照页面上的提示把你的代码push上去  git init git remote add origin https://github.com/<your-name>/<your-repository>.git git add . git commit -am \"Initial commit.\" git push origin master"},{"h2":"安装","h3":"远程安装","h4":"发布release","name":"release","content":"可以用下面的方式在本地发布版本  git tag 0.0.1 && git push --tags  也可以在Github的仓库页面的Releases页面手动设置"},{"h2":"安装","h3":"远程安装","h4":"发布到Packagist.org","name":"packagist","content":"接下来就是发布你的项目到Packagist.org，如果没有账号的话，先注册一个，然后打开顶部导航的Submit, 填入仓库地址提交  默认情况下，当您推送新代码时，Packagist.org不会自动更新，所以，您需要创建一个GitHub服务钩子， 你也可以使用点击页面上的Update按钮手动更新它，但我建议自动执行这个过程  提交之后，由于各地的镜像同步时间的延迟，可能在用composer安装的时候，会暂时找不到你的项目，这个时候可能需要等待同步完成  发布完成之后就可以通过composer安装你的扩展了  加入到https://github.com/dcat-admin-extensions 如果想把你开发的扩展加入到dcat-admin-extensions，欢迎用各种方式联系我，这样可以让更多人看到并使用你开发的工具。"},{"h2":"导入和启用扩展","h3":"导入扩展","h4":"","name":"importext","content":"安装完成后，运行以下命令即可以导入扩展，导入的文件主要有：静态资源文件、菜单、权限等。   视图、数据库迁移文件、语言包一般不需要导入。如果要导入其他文件，需要扩展开发者自行定义。 另外此命令允许重复执行。   php artisan admin:import Dcat\\Admin\\Extension\\Gank\\Gank"},{"h2":"导入和启用扩展","h3":"启用扩展","h4":"","name":"enable","content":"扩展的启用与否是通过配置文件控制的，打开/config/admin-extension.php，加入以下代码：  return [ 'gank' => [ 'enable' => true, ], ];"},{"h2":"导入和启用扩展","h3":"可视化管理扩展","h4":"","name":"view","content":"访问http://localhost:8000/admin/helpers/extensions，可以通过页面操作启用或关闭扩展、导入扩展。   如果/config/admin-extension.php不存在，系统会自动创建   这样就完成了安装，打开http://localhost/admin/gank访问这个扩展。"}]},{"title":"开发工具","link":"extension-helpers","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"在最新的版本中新增了面向开发人员的帮助工具，能在开发中提供帮助提高效率，目前提供脚手架，数据库命令行和artisan命令行三个工具，如果有更好的其它实用工具的想法，欢迎提供建议。 安装： composer require dcat-admin-ext/helpers php artisan admin:import helpers 工具的部分功能会在项目中创建或删除文件，可能会出现文件或目录权限的问题，这个问题需要自行解决。 另外部分数据库和artisan命令无法在web环境下使用。 "},{"h2":"脚手架工具","h3":"","h4":"","name":"脚手架工具-h2","content":"脚手架工具能帮你一键生成控制器、模型、迁移文件，并运行迁移文件，访问http://localhost/admin/helpers/scaffold打开。  其中设置迁移表结构的时候，主键字段是自动生成的不需要填写。"},{"h2":"数据库命令行","h3":"","h4":"","name":"数据库命令行-h2","content":"数据库命令行工具的web集成，目前支持mysql、mongodb 和 redis，访问http://localhost/admin/helpers/terminal/database打开。  在右上角的select选择框切换数据库连接，然后在底部的输入框输入对应数据库的查询语句然后回车，就能得到查询结果：  实用方式和终端上操作数据库是一致的，可以运行所选择数据库的所支持的查询语句。"},{"h2":"artisan命令行工具","h3":"","h4":"","name":"artisan命令行工具-h2","content":"Laravel的artisan命令的web实现，可以在上面运行artisan命令，访问http://localhost/admin/helpers/terminal/artisan打开。"},{"h2":"路由列表","h3":"","h4":"","name":"路由列表-h2","content":"这个工具能用用比较直观的展现出系统的所有路由，包括路由的uri、方法和中间件等，还能查询路由。访问http://localhost/admin/helpers/routes打开。"}]},{"title":"扩展","link":"extensions","nodes":[{"h2":"","h3":"","h4":"","name":"","content":" 扩展 描述 dcat-admin 版本 dcat-page 一个简洁的静态站点构建工具 * ueditor 百度在线编辑器 * gank 干货集中营 * "}]},{"title":"帮助函数","link":"function","nodes":[{"h2":"","h3":"admin_path","h4":"","name":"admin_path-h3","content":"获取Dcat Admin安装的应用路径，默认目录是app/Admin：  $bootstrap = admin_path('bootstrap.php');"},{"h2":"","h3":"admin_url","h4":"","name":"admin_url-h3","content":"获取Dcat Admin应用的路由完整url：  // 返回： http://localhost/admin/auth/users $url = admin_url('auth/users');"},{"h2":"","h3":"admin_base_path","h4":"","name":"admin_base_path-h3","content":"获取Dcat Admin应用的路由路径：  // 返回： /admin/auth/users $path = admin_base_path('auth/users');"},{"h2":"","h3":"admin_alert","h4":"","name":"admin_alert-h3","content":"在页面刷新后弹出一个layer提示窗，参数：   $message 提示窗内容 $type 提示窗类型，默认success，支持success、info、warning、error $offset 提示窗位置，支持t、b、rt、rb   admin_alert('更新成功', 'success', 'rt');"},{"h2":"","h3":"admin_success","h4":"","name":"admin_success-h3","content":"在页面刷新后在页面顶部显示一个成功消息：  admin_success('标题', '成功了');"},{"h2":"","h3":"admin_error","h4":"","name":"admin_error-h3","content":"在页面刷新后在页面顶部显示一个错误消息：  admin_error('标题', '失败了');"},{"h2":"","h3":"admin_warning","h4":"","name":"admin_warning-h3","content":"在页面刷新后在页面顶部显示一个警告消息：  admin_warning('标题', '警告');"},{"h2":"","h3":"admin_info","h4":"","name":"admin_info-h3","content":"在页面刷新后在页面顶部显示一个提示消息：  admin_info('标题', '内容');"},{"h2":"","h3":"admin_asset","h4":"","name":"admin_asset-h3","content":"获取静态资源的完整链接：  // 引入css <link rel=\"stylesheet\" href=\"{{ admin_asset(\"vendor/dcat-admin/dcat-admin/main.min.css\") }}\"> // 引入js <script src=\"{{ admin_asset('vendor/dcat-admin/dcat-admin/main.min.js')}}\"></script>"},{"h2":"","h3":"admin_trans_field","h4":"","name":"admin_trans_field-h3","content":"翻译当前控制器的字段，控制器名称去除Controller后缀之后再转化为小写中划线就是语言包的名称，如：控制器名称为UserProfileController，则对应的语言包名称为user-profile.php。   如果当前控制器对应的语言包中不存在该字段翻译，则会去公共翻译文件global.php中查找。   $name = admin_trans_field('name'); $createdAt = admin_trans_field('created_at');  语言包内容如下：  return [ 'fields' => [ 'name' => '名称', 'created_at' => '创建时间', ], ];"},{"h2":"","h3":"admin_trans_label","h4":"","name":"admin_trans_label-h3","content":"翻译当前控制器的自定义内容，控制器名称去除Controller后缀之后再转化为小写中划线就是语言包的名称，如：控制器名称为UserProfileController，则对应的语言包名称为user-profile.php。   如果当前控制器对应的语言包中不存在该字段翻译，则会去公共翻译文件global.php中查找。   $user = admin_trans_label('User');  语言包内容如下：  return [ 'labels' => [ 'User' => '管理员', ], ];"},{"h2":"","h3":"admin_trans_option","h4":"","name":"admin_trans_option-h3","content":"翻译当前控制器的字段选项值，控制器名称去除Controller后缀之后再转化为小写中划线就是语言包的名称，如：控制器名称为UserProfileController，则对应的语言包名称为user-profile.php。   如果当前控制器对应的语言包中不存在该字段翻译，则会去公共翻译文件global.php中查找。   $status = admin_trans_option(1, 'status');  语言包内容如下：  return [ 'options' => [ 'status' => [ 1 => '启用', 0 => '禁用' ], ], ];"}]},{"title":"开发工具","link":"helpers","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"Dcat Admin提供了一些开发工具以帮助开发者提升开发效率，以下所有工具都需要开启app.debug配置参数后才能使用。"},{"h2":"","h3":"代码生成器","h4":"","name":"代码生成器-h3","content":"代码生成器可以通过界面一键生成增删改查代码，支持根据已有数据表生成增删改查代码，打开浏览器访问http://localhost:8000/admin/helpers/scaffold即可使用。"},{"h2":"","h3":"扩展包管理","h4":"","name":"扩展包管理-h3","content":"Dcat Admin支持可视化管理扩展包，只要通过composer安装进来的扩展包都能在管理界面中看到，支持通过界面启用和导入扩展包，打开浏览器访问http://localhost:8000/admin/helpers/extensions即可使用。"},{"h2":"","h3":"IDE自动补全","h4":"","name":"IDE自动补全-h3","content":"通过php artisan admin:ide-helper命令可以生成IDE自动补全文件，可以生成Grid、Form、Show等功能的IDE自动补全提示文件。"},{"h2":"","h3":"图标","h4":"","name":"图标-h3","content":"访问http://localhost:8000/admin/helpers/icons可以查看已支持的图标列表。"},{"h2":"","h3":"路由","h4":"","name":"路由-h3","content":"访问http://localhost:8000/admin/helpers/routes可以查看已注册的路由列表。"}]},{"title":"安装","link":"installation","nodes":[{"h2":"环境","h3":"","h4":"","name":"env","content":" PHP >= 7.1 Laravel 5.5.0 ~ 7.* Fileinfo PHP Extension "},{"h2":"开始安装","h3":"","h4":"","name":"start","content":"首先需要安装laravel，如已安装可以跳过此步骤  composer create-project --prefer-dist laravel/laravel 项目名称 7.* # 或 composer create-project --prefer-dist laravel/laravel 项目名称  安装完laravel之后需要设置数据库连接设置正确  composer require dcat/laravel-admin  然后运行下面的命令来发布资源：  php artisan admin:publish  在该命令会生成配置文件config/admin.php，可以在里面修改安装的地址、数据库连接、以及表名，建议都是用默认配置不修改。  然后运行下面的命令完成安装：  php artisan admin:install  启动服务后，在浏览器打开 http://localhost/admin/ ,使用用户名 admin 和密码 admin登陆."},{"h2":"生成的文件","h3":"","h4":"","name":"files","content":"安装完成之后,会在项目目录中生成以下的文件:"},{"h2":"生成的文件","h3":"配置文件","h4":"","name":"config","content":"安装完成之后，dcat-admin所有的配置都在config/admin.php文件中。"},{"h2":"生成的文件","h3":"后台项目文件","h4":"","name":"admin","content":"安装完成之后，后台的安装目录为app/Admin，之后大部分的后台开发编码工作都是在这个目录下进行。  app/Admin ├── Controllers │   ├── ExampleController.php │   └── HomeController.php ├── Metrics │   └── Examples │   ├── NewDevices.php │   ├── NewUsers.php │   ├── ProductOrders.php │   ├── Sessions.php │   ├── Tickets.php │   └── TotalUsers.php ├── bootstrap.php └── routes.php   app/Admin/routes.php文件用来配置后台路由。 app/Admin/bootstrap.php 是dcat-admin的启动文件, 使用方法请参考文件里面的注释. app/Admin/Controllers目录用来存放后台控制器文件，该目录下的HomeController.php文件是后台首页的显示控制器，ExampleController.php为实例文件。 app/Admin/Metrics/Examples里面存放的是数据统计卡片(Metric Card)的示例代码. "},{"h2":"生成的文件","h3":"静态文件","h4":"","name":"assets","content":"后台所需的前端静态文件在/public/vendor/dcat-admin目录下。"},{"h2":"生成的文件","h3":"数据表迁移文件","h4":"","name":"migrations","content":"对应的数据表迁移文件在/database/migrations目录下。"},{"h2":"生成的文件","h3":"语言包","h4":"","name":"lang","content":"语言包文件在/resources/lang目录下。"},{"h2":"版本升级","h3":"","h4":"","name":"版本升级-h2","content":"升级命令  composer update dcat/laravel-admin  升级成功之后一般需要重新发布语言包、配置文件、前端静态资源和数据库迁徙等文件  php artisan admin:publish --force  只更新语言包  php artisan admin:publish --force --lang  只更新配置文件  php artisan admin:publish --force --config  只更新前端静态资源  php artisan admin:publish --force --assets  只更新数据库迁徙文件  php artisan admin:publish --force --migrations"}]},{"title":"Dcat Admin","link":"introduction","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"Dcat Admin 是一个基于laravel-admin二次开发而成的后台构建工具，只需极少的代码即可构建出一个功能完善且颜值极高的后台系统。 "},{"h2":"技术栈","h3":"","h4":"","name":"技术栈-h2","content":" jQuery3 "},{"h2":"特性","h3":"","h4":"","name":"特性-h2","content":" 用户管理（可拆卸） RBAC权限管理（可拆卸），支持无限极权限节点 菜单管理（可拆卸） 使用PJAX构建无刷新页面，并且支持按需加载静态资源 松耦合的页面构建与数据操作设计，可轻松切换数据源 插件功能 可视化代码生成器，可根据数据表一键生成增删改查页面 数据表格构建工具，内置丰富的表格常用功能（如组合表头、数据导出、搜索、快捷创建、批量操作等） 树状表格功能构建工具，支持分页和点击加载 数据表单构建工具，内置 50+ 种表单类型，支持异步提交 分步表单构建工具 弹窗表单构建工具 数据详情页构建工具 无限层级树状页面构建工具，支持用拖拽的方式实现数据的层级、排序等操作 内置 40+ 种常用页面组件（如图表、下拉菜单、Tab卡片、提示工具、提示卡片等） Section功能（类似Wordpress的过滤器Filter） 异步文件上传表单，支持分块上传 "},{"h2":"与Laravel Admin的异同","h3":"","h4":"","name":"与LaravelAdmin的异同-h2","content":"Dcat Admin是基于Laravel Admin二次开发而成的后台构建工具，整体风格与Laravel Admin一脉相承，只是在功能细节上做了大量的调整。  调整：   采用vuexy(bootstrap4+jQuery3)构建前端页面 使用PJAX构建无刷新页面，并且支持前端资源按需加载，开发者无需再担心安装组件过多会影响页面加载速度 采用松耦合的页面构建与操作数据设计，构建页面不再需要关心数据操作接口的具体实现 调整了表单提交方式，改为ajax提交 调整了代码生成器，支持根据已有数据表一键生成增删改查页面 调整了多语言翻译功能，使用更简单 调整了权限功能，支持分层级以及排序 调整了扩展系统，支持页面管理，拆卸安装更方便 ...   新增：   新增表单弹窗功能，仅需增加数行代码就可以构建一个非Iframe表单弹窗 新增快速构建无菜单栏页面功能 新增SelectResource表单，可以在弹窗中选择表格数据 新增AJAX提价表单以及表单前端验证功能 新增文件异步上传组件，支持分块上传、批量上传、上传进度条等 新增了表格过滤器右侧滑动面板布局 新增了表格字段值过滤功能 新增了分步表单 新增section功能（与wordpress的add_filter功能类似） 新增树形表格功能，可分页显示大批量的层级结构数据 新增双表头表格功能，仅需增加数行代码即可构建出双表头表格 新增了多种实用的页面组件，如图表、下拉菜单、markdown、checkbox等等 新增Tree表单 新增通过数组添加菜单的功能，支持绑定权限和角色 新增通过数组添加菜单功能 新增菜单缓存功能 ... "}]},{"title":"JS组件","link":"js","nodes":[]},{"title":"菜单","link":"menu","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"Dcat Admin的菜单是保存在数据表admin_menu上的，开发者可以在后台菜单管理页面对菜单进行管理。"},{"h2":"","h3":"菜单权限","h4":"","name":"菜单权限-h3","content":"每个菜单都可以与权限或角色进行绑定，如果不设置则为公共菜单，所有账号都能看到。  通过admin.menu.bind_permission配置参数可以设置是否允许绑定权限。   默认一个菜单最多能绑定一个权限和一个角色。 "},{"h2":"","h3":"菜单翻译","h4":"","name":"菜单翻译-h3","content":"在您的语言文件的menu_titles索引中追加菜单标题。 例如“工作单位”标题：  在resources/lang/{当前语言}/admin.php中  ... 'menu_titles' => [ 'work_units' => 'Unidades de trabajo' ],"},{"h2":"","h3":"菜单缓存","h4":"","name":"菜单缓存-h3","content":"通过admin.menu.cache.enable配置参数可以开启或关闭菜单缓存，建议开启。"},{"h2":"","h3":"通过Menu::add接口动态添加菜单","h4":"","name":"通过Menu::add接口动态添加菜单-h3","content":"Dcat Admin还提供了通过数组的方式在代码中即时添加菜单。  在app\\Admin\\bootstrap.php中添加如下代码：  <?php use Dcat\\Admin\\Admin; use Dcat\\Admin\\Layout\\Menu; Admin::menu(function (Menu $menu) { $menu->add([ [ 'id' => '1', // 此id只要保证当前的数组中是唯一的即可 'title' => '测试菜单', 'icon' => 'fa-file-text-o', 'uri' => '', 'parent_id' => 0, 'permission_id' => 'test', // 与权限绑定 'roles' => 'test-roles', // 与角色绑定 ], [ 'id' => '2', // 此id只要保证当前的数组中是唯一的即可 'title' => '测试菜单2', 'icon' => 'fa-file-text-o', 'uri' => 'test-menu2', 'parent_id' => '1', ], ]); }); "}]},{"title":"表单回调","link":"model-form-callback","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"Form目前提供了下面几个方法来接收回调函数："},{"h2":"","h3":"creating","h4":"","name":"creating-h3","content":"在新增页面调用（非提交操作）  $form->creating(function (Form $form) { ... });"},{"h2":"","h3":"editing","h4":"","name":"editing-h3","content":"在编辑页面调用（非提交操作）  $form->editing(function (Form $form) { ... });"},{"h2":"","h3":"submitted","h4":"","name":"submitted-h3","content":"在表单提交前调用  $form->submitted(function (Form $form) { // 获取用户提交参数 $title = $form->title; // 上面写法等同于 $title = $form->input('title'); });"},{"h2":"","h3":"saving","h4":"","name":"saving-h3","content":"保存前回调  $form->saving(function (Form $form) { // 判断是否是新增操作 if ($form->isCreating()) { } });"},{"h2":"","h3":"saved","h4":"","name":"saved-h3","content":"保存后回调  $form->saved(function (Form $form) { // 判断是否是新增操作 if ($form->isCreating()) { } });"},{"h2":"","h3":"deleting","h4":"","name":"deleting-h3","content":"删除前回调  $form->deleting(function (Form $form) { // 跳转 return $form->redirect('auth/user', [ 'message' => '删除失败', 'status' => false, ]); });"},{"h2":"","h3":"deleted","h4":"","name":"deleted-h3","content":"删除后回调  $form->deleted(function (Form $form) { // ... });"},{"h2":"","h3":"获取模型中的数据","h4":"","name":"获取模型中的数据-h3","content":"$form->saved(function (Form $form) { $id = $form->getKey(); $username = $form->model()->username; // 获取最终保存的数组 $form->getUpdates(); });"},{"h2":"","h3":"页面跳转","h4":"","name":"页面跳转-h3","content":"可在任意回调事件内使用  // 跳转并提示成功信息 $form->saved(function (Form $form) { return $form->redirect('auth/user', '保存成功'); }); // 跳转并提示错误信息 $form->creating(function (Form $form) { return $form->redirect('auth/user', [ 'message' => '系统错误', 'status' => false, ]); });"},{"h2":"","h3":"返回字段验证出错信息","h4":"","name":"返回字段验证出错信息-h3","content":" // 跳转并提示错误信息 $form->creating(function (Form $form) { if (...) { // 你的验证逻辑 $form->responseValidationMessages('title', 'title格式错误'); // 如有多个错误信息，第二个参数可以传数组 $form->responseValidationMessages('content', ['content格式错误', 'content不能为空']); } });"}]},{"title":"表单数据源","link":"model-form-data","nodes":[{"h2":"模型与数据仓库","h3":"","h4":"","name":"模型与数据仓库-h2","content":"Dcat Admin中表单对数据的操作并非直接依赖于Eloquent Model，而是依赖于Repository提供的数据操作接口。   Repository提供更简单更清晰数据操作接口，开发者可以通过实现不同的数据操作接口轻松支持多数据源，具体使用方法请参照数据仓库。 "},{"h2":"数据来自模型","h3":"","h4":"","name":"数据来自模型-h2","content":"当数据源支持模型时，只需创建一个非常简单的Repository类既可：  <?php namespace App\\Admin\\Repositories; use Dcat\\Admin\\Repositories\\EloquentRepository; use App\\Models\\Movie as MovieModel; class Movie extends EloquentRepository { // 这里定义你的模型类名 protected $eloquentClass = MovieModel::class; // 通过这个方法可以指定表单页查询的字段，默认\"*\" public function getFormColumns() { return [$this->getKeyName(), 'name', 'title', 'created_at']; } }  使用：  use App\\Admin\\Repositories\\Movie; $form = new Form(new Movie); ..."},{"h2":"数据来自外部API","h3":"","h4":"","name":"数据来自外部API-h2","content":"当下面用豆瓣电影的API为例子，来展示Repository的写操作相关接口：  <?php namespace App\\Admin\\Repositories; use Dcat\\Admin\\Repositories\\Repository; use Dcat\\Admin\\Form; class ComingSoon extends Repository { protected $api = 'https://api.douban.com/v2/movie/coming_soon'; // 返回你的id字段名称，默认“id” protected $keyName = '_id'; // 查询编辑页数据 // 这个方法需要返回一个数组 public function edit(Form $form): array { // 获取id $id = $form->builder()->getResourceId(); $data = file_get_contents(\"http://api.douban.com/v2/movie/subject/$id\"); return json_decode($data, true); } // 这个方法用于在修改数据前查询原记录 // 如果使用了文件上传表单，当文件发生变更时会根据这个原始记录自动删除旧文件 // 如果不需要此数据返回空数组即可 public function getDataWhenUpdating(Form $form): array { // 获取id $id = $form->builder()->getResourceId(); return []; } // 修改操作 // 返回一个bool类型的数据 public function update(Form $form) { // 获取id $id = $form->builder()->getResourceId(); // 获取要修改的数据 $attributes = $form->getUpdates(); // TODO // 这里写你的修改逻辑 return true; } // 这个方法用于在修改数据前查询原始数据 // 如果使用了文件上传表单，会根据这个数据自动删除文件 // 如果不需要此数据返回空数组即可 public function getDataWhenDeleting(Form $form): array { $id = $form->builder()->getResourceId(); $id = explode(',', $id); // $data = file_get_contents(\"http://api.douban.com/v2/movie/subject/$id\"); // // return json_decode($data, true); return []; } // 删除数据 // $deletingData 是由 getDataWhenDeleting 方法返回的数据 public function destroy(Form $form, array $deletingData) { // 注意这里的id可能是多个 $id = $form->builder()->getResourceId(); // 当使用批量删除功能时，这里的id是用“,”隔开的字符串 $id = explode(',', $id); // TODO // var_dump($id, $deletingData); return true; } }"}]},{"title":"Form组件管理","link":"model-form-field-management","nodes":[{"h2":"移除已有组件","h3":"","h4":"","name":"移除已有组件-h2","content":"找到文件app/Admin/bootstrap.php,如果文件不存在，请新建该文件  <?php use Dcat\\Admin\\Form; Form::forget('map'); Form::forget('editor'); // or Form::forget(['map', 'editor']);   这样就去掉了这两个组件，可以通过该方式去掉其它组件。"},{"h2":"扩展自定义组件","h3":"","h4":"","name":"扩展自定义组件-h2","content":" 扩展自定义Form组件后IDE默认是不会自动补全的，这时候可以通过php artisan admin::ide-helper生成IDE提示文件，具体请参考IDE自动补全。 "},{"h2":"扩展自定义组件","h3":"集成富文本编辑器wangEditor","h4":"","name":"集成富文本编辑器wangEditor-h3","content":"wangEditor是一个优秀的国产的轻量级富文本编辑器，如果dcat-admin自带的基于ckeditor的编辑器组件使用上有问题，可以通过下面的步骤可以集成它，并覆盖掉ckeditor：  先下载前端库文件wangEditor，解压到目录public/vendor/wangEditor-3.0.9。  然后新建组件类app/Admin/Extensions/WangEditor.php。   <?php namespace App\\Admin\\Extensions; use Dcat\\Admin\\Form\\Field; class WangEditor extends Field { protected $view = 'admin.wang-editor'; protected static $css = [ '/vendor/wangEditor-3.0.9/release/wangEditor.min.css', ]; protected static $js = [ '/vendor/wangEditor-3.0.9/release/wangEditor.min.js', ]; public function render() { $name = $this->formatName($this->column); $this->script = <<<EOT var E = window.wangEditor var editor = new E('#{$this->id}'); editor.customConfig.zIndex = 0 editor.customConfig.uploadImgShowBase64 = true editor.customConfig.onchange = function (html) { $('input[name=$name]').val(html); } editor.create() EOT; return parent::render(); } }   新建视图文件resources/views/admin/wang-editor.blade.php：  <div class=\"form-group {!! !$errors->has($label) ?: 'has-error' !!}\"> <label for=\"{{$id}}\" class=\"col-sm-2 control-label\">{{$label}}</label> <div class=\"{{$viewClass['field']}}\"> @include('admin::form.error') <div id=\"{{$id}}\" style=\"width: 100%; height: 100%;\"> <p>{!! old($column, $value) !!}</p> </div> <input type=\"hidden\" name=\"{{$name}}\" value=\"{{ old($column, $value) }}\" /> </div> </div>  然后注册进dcat-admin,在app/Admin/bootstrap.php中添加以下代码：   <?php use App\\Admin\\Extensions\\WangEditor; use Dcat\\Admin\\Form; Form::extend('editor', WangEditor::class);   调用:   $form->editor('body'); "},{"h2":"扩展自定义组件","h3":"集成富文本编辑器ckeditor","h4":"","name":"集成富文本编辑器ckeditor-h3","content":"先下载ckeditor 并解压到/public目录，比如放在/public/packages/目录下。  然后新建扩展文件app/Admin/Extensions/Form/CKEditor.php:  <?php namespace App\\Admin\\Extensions\\Form; use Dcat\\Admin\\Form\\Field; class CKEditor extends Field { public static $js = [ '/packages/ckeditor/ckeditor.js', '/packages/ckeditor/adapters/jquery.js', ]; protected $view = 'admin.ckeditor'; public function render() { $this->script = \"$('textarea.{$this->getElementClass()}').ckeditor();\"; return parent::render(); } }  新建view resources/views/admin/ckeditor.blade.php:  <div class=\"form-group {!! !$errors->has($errorKey) ?: 'has-error' !!}\"> <label for=\"{{$id}}\" class=\"col-sm-2 control-label\">{{$label}}</label> <div class=\"col-sm-6\"> @include('admin::form.error') <textarea class=\"form-control {{ $class }}\" name=\"{{$name}}\" placeholder=\"{{ $placeholder }}\" {!! $attributes !!} >{{ old($column, $value) }}</textarea> @include('admin::form.help-block') </div> </div>   然后在app/Admin/bootstrap.php中引入扩展：  use App\\Admin\\Extensions\\Form\\CKEditor; use Dcat\\Admin\\Form; Form::extend('ckeditor', CKEditor::class);  然后就能在form中使用了:  $form->ckeditor('content');"},{"h2":"扩展自定义组件","h3":"集成PHP editor","h4":"","name":"集成PHPeditor-h3","content":"通过下面的步骤来扩展一个基于codemirror的PHP代码编辑器，效果参考PHP mode。  先将codemirror库下载并解压到前端资源目录下，比如放在public/packages/codemirror-5.20.2目录下。  新建组件类app/Admin/Extensions/PHPEditor.php:  <?php namespace App\\Admin\\Extensions; use Dcat\\Admin\\Form\\Field; class PHPEditor extends Field { protected $view = 'admin.php-editor'; protected static $css = [ '/packages/codemirror-5.20.2/lib/codemirror.css', ]; protected static $js = [ '/packages/codemirror-5.20.2/lib/codemirror.js', '/packages/codemirror-5.20.2/addon/edit/matchbrackets.js', '/packages/codemirror-5.20.2/mode/htmlmixed/htmlmixed.js', '/packages/codemirror-5.20.2/mode/xml/xml.js', '/packages/codemirror-5.20.2/mode/javascript/javascript.js', '/packages/codemirror-5.20.2/mode/css/css.js', '/packages/codemirror-5.20.2/mode/clike/clike.js', '/packages/codemirror-5.20.2/mode/php/php.js', ]; public function render() { $this->script = <<<EOT CodeMirror.fromTextArea(document.getElementById(\"{$this->id}\"), { lineNumbers: true, mode: \"text/x-php\", extraKeys: { \"Tab\": function(cm){ cm.replaceSelection(\" \" , \"end\"); } } }); EOT; return parent::render(); } }    类中的静态资源也同样可以从外部引入，参考Editor.php   创建视图resources/views/admin/php-editor.blade.php:   <div class=\"form-group {!! !$errors->has($label) ?: 'has-error' !!}\"> <label for=\"{{$id}}\" class=\"col-sm-2 control-label\">{{$label}}</label> <div class=\"col-sm-6\"> @include('admin::form.error') <textarea class=\"form-control\" id=\"{{$id}}\" name=\"{{$name}}\" placeholder=\"{{ trans('admin::lang.input') }} {{$label}}\" {!! $attributes !!} >{{ old($column, $value) }}</textarea> </div> </div>   最后找到文件app/Admin/bootstrap.php,如果文件不存在，请更新dcat-admin，然后新建该文件,添加下面代码：  <?php use App\\Admin\\Extensions\\PHPEditor; use Dcat\\Admin\\Form; Form::extend('php', PHPEditor::class);   这样就能在model-form中使用PHP编辑器了：   $form->php('code');   通过这种方式，可以添加任意你想要添加的form组件。"}]},{"title":"Form组件使用","link":"model-form-fields","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"在model-form中内置了大量的form组件来帮助你快速的构建form表单"},{"h2":"公共方法","h3":"设置保存值","h4":"","name":"value","content":"$form->text('title')->value('text...');"},{"h2":"公共方法","h3":"设置默认值","h4":"","name":"default","content":"$form->text('title')->default('text...');"},{"h2":"公共方法","h3":"设置help信息","h4":"","name":"help","content":"$form->text('title')->help('help...');"},{"h2":"公共方法","h3":"设置属性","h4":"","name":"attr","content":"$form->text('title')->attribute(['data-title' => 'title...']); $form->text('title')->attribute('data-title', 'title...');"},{"h2":"公共方法","h3":"设置为必填","h4":"","name":"required","content":"$form->text('title')->required(); // 不显示\"*\"号 $form->text('title')->required(false);"},{"h2":"公共方法","h3":"设置为不可编辑","h4":"","name":"disable","content":"$form->text('title')->disable();"},{"h2":"公共方法","h3":"设置placeholder","h4":"","name":"placeholder","content":"$form->text('title')->placeholder('请输入。。。');"},{"h2":"公共方法","h3":"设置宽度","h4":"","name":"setWidth","content":"$form->text('title')->setWidth(8, 2);"},{"h2":"公共方法","h3":"设置验证规则","h4":"","name":"rules","content":"具体使用可参考表单验证。"},{"h2":"公共方法","h3":"处理待保存的数据","h4":"","name":"saving","content":"saving方法可以更改待保存到数据库的数据。如下面的例子，原本表单提交的是一个以“,”隔开的字符串，我们可以把这个值转化成json格式保存到数据库  $form->mutipleFile('files')->saving(function ($paths) { // 把“,”隔开的字符串转化为数组 $paths = Helper::array($paths); // 最终转化为json保存到数据库 return json_encode($paths); });"},{"h2":"公共方法","h3":"处理待渲染的数据","h4":"","name":"customFormat","content":"customFormat方法可以改变从外部注入到表单的字段值。  如上面的例子，我们把原本是以“,”隔开的字符串改为json格式保存到数据库，那么从数据库中取出的值也是json，这个时候直接注入到表单后并不能被表单识别，所以需要通过customFormat方法把这个值重新转回以“,”隔开的字符串。  $form->mutipleFile('files')->saving(function ($paths) { $paths = Helper::array($paths); return json_encode($paths); })->customFormat(function ($paths) { if (!$paths) return ''; // 转化为数组 $paths = json_decode($paths, true); // 转为以“,”隔开的字符串 return join(',', $paths); });"},{"h2":"公共方法","h3":"在弹窗中隐藏","h4":"","name":"在弹窗中隐藏-h3","content":"如果不想在弹窗中显示某个字段，可以使用Form\\Field::hideInModal方法  $form->display('id'); $form->text('title'); $form->textare('contents')->hideInModal();"},{"h2":"model-form-tab","h3":"","h4":"","name":"tab","content":"如果表单元素太多,会导致form页面太长, 这种情况下可以使用tab来分隔form:   $form->tab('Basic info', function ($form) { $form->text('username'); $form->email('email'); })->tab('Profile', function ($form) { $form->image('avatar'); $form->text('address'); $form->mobile('phone'); })->tab('Jobs', function ($form) { $form->hasMany('jobs', function () { $form->text('company'); $form->date('start_date'); $form->date('end_date'); }); }) "},{"h2":"text","h3":"","h4":"","name":"text","content":"$form->text($column, [$label]); // 添加提交验证规则 $form->text($column, [$label])->rules('required|min:10');"},{"h2":"select","h3":"","h4":"","name":"select","content":"$form->select($column[, $label])->options([1 => 'foo', 2 => 'bar', 'val' => 'Option name']);  或者从api中获取选项列表：  $form->select($column[, $label])->options('/api/users'); // 使用ajax并显示所选项目 $form->select($column[, $label])->options(Model::class)->ajax('/api/users'); // 或指定名称和ID $form->select($column[, $label])->options(Model::class, 'name', 'id')->ajax('/api/users');  其中api接口的格式必须为下面格式：  [ { \"id\": 9, \"text\": \"xxx\" }, { \"id\": 21, \"text\": \"xxx\" }, ... ]  如果选项过多，可通过ajax方式动态分页载入选项：  $form->select('user_id')->options(function ($id) { $user = User::find($id); if ($user) { return [$user->id => $user->name]; } })->ajax('/admin/api/users');  注：如果你修改了config/admin.php配置文件中route.prefix的值，此处的接口路由应该修改为config('admin.route.prefix').'/api/users'。  API /admin/api/users接口的代码：  public function users(Request $request) { $q = $request->get('q'); return User::where('name', 'like', \"%$q%\")->paginate(null, ['id', 'name as text']); }   接口返回的数据结构为  { \"total\": 4, \"per_page\": 15, \"current_page\": 1, \"last_page\": 1, \"next_page_url\": null, \"prev_page_url\": null, \"from\": 1, \"to\": 3, \"data\": [ { \"id\": 9, \"text\": \"xxx\" }, { \"id\": 21, \"text\": \"xxx\" }, { \"id\": 42, \"text\": \"xxx\" }, { \"id\": 48, \"text\": \"xxx\" } ] }"},{"h2":"select 联动","h3":"","h4":"","name":"selectload","content":"select组件支持父子关系的单向联动：  $form->select('province')->options(...)->load('city', '/api/city'); $form->select('city');   其中load('city', '/api/city');的意思是，在当前select的选项切换之后，会把当前选项的值通过参数q, 调用接口/api/city，并把api返回的数据填充为city选择框的选项，其中api/api/city返回的数据格式必须符合:  [ { \"id\": 9, \"text\": \"xxx\" }, { \"id\": 21, \"text\": \"xxx\" }, ... ]  控制器action的代码示例如下：  public function city(Request $request) { $provinceId = $request->get('q'); return ChinaArea::city()->where('parent_id', $provinceId)->get(['id', DB::raw('name as text')]); }"},{"h2":"multipleSelect","h3":"","h4":"","name":"multipleSelect","content":" 注入这个字段的数据（从数据库查出来的）可以是一个以“,”隔开的字符串或数组。   $form->multipleSelect($column[, $label])->options([1 => 'foo', 2 => 'bar', 'val' => 'Option name']); // 使用ajax并显示所选项目： $form->multipleSelect($column[, $label])->options(Model::class)->ajax('ajax_url'); // 或指定名称和ID $form->multipleSelect($column[, $label])->options(Model::class, 'name', 'id')->ajax('ajax_url');  多选框可以处理两种情况，第一种是ManyToMany的关系。   class Post extends Models { public function tags() { return $this->belongsToMany(Tag::class); } } $form->multipleSelect('tags')->options(Tag::all()->pluck('name', 'id'));   第二种是将选项数组存储到单字段中，如果字段是字符串类型，那就需要在模型里面为该字段定义访问器和修改器来存储和读取了。  如果选项过多，可通过ajax方式动态分页载入选项：  $form->select('friends')->options(function ($ids) { return User::find($ids)->pluck('name', 'id'); })->ajax('/admin/api/users');  注：如果你修改了config/admin.php配置文件中route.prefix的值，此处的接口路由应该修改为config('admin.route.prefix').'/api/users'。  API /admin/api/users接口的代码：  public function users(Request $request) { $q = $request->get('q'); return User::where('name', 'like', \"%$q%\")->paginate(null, ['id', 'name as text']); }   接口返回的数据结构为  { \"total\": 4, \"per_page\": 15, \"current_page\": 1, \"last_page\": 1, \"next_page_url\": null, \"prev_page_url\": null, \"from\": 1, \"to\": 3, \"data\": [ { \"id\": 9, \"text\": \"xxx\" }, { \"id\": 21, \"text\": \"xxx\" }, { \"id\": 42, \"text\": \"xxx\" }, { \"id\": 48, \"text\": \"xxx\" } ] }"},{"h2":"selectResource","h3":"","h4":"","name":"selectResource","content":"选择数据源，选择弹窗里面的表格数据。   注入这个字段的数据（从数据库查出来的）可以是一个以“,”隔开的字符串或数组。    $form->selectResource('user') ->path('auth/users') // 设置表格页面链接 ->options(function ($v) { // 显示已选中的数据 if (!$v) return $v; $userModel = config('admin.database.users_model'); return $userModel::findOrFail($v)->pluck('name', 'id'); }); // 设置为多选 $form->selectResource('user') ->path('auth/users') ->multiple() // 设置为多选 ->options(function ($v) { ... }); // 限制最大选择数量 $form->selectResource('user') ->path('auth/users') ->multiple(3) // 最多选择3个选项 ->options(function ($v) { ... });   auth/users页面实现代码如下：  /** * Index interface. * * @return Content */ public function index(Content $content) { if (request('_mini')) { return $content->body($this->miniGrid()); } ... } protected function miniGrid() { $grid = new MiniGrid(new Administrator()); // 指定行选择器选中时显示的值的字段名称 // 指定行选择器选中时显示的值的字段名称 // 指定行选择器选中时显示的值的字段名称 // 如果表格数据中带有 “name”、“title”或“username”字段，则可以不用设置 $grid->setRowSelectorOptions(['label_name' => 'username']); $grid->id->sortable(); $grid->username; $grid->name; $grid->filter(function (Grid\\Filter $filter) { $filter->equal('id'); $filter->like('username'); $filter->like('name'); }); return $grid; }"},{"h2":"listbox","h3":"","h4":"","name":"listbox","content":"使用方法和multipleSelect类似。   注入这个字段的数据（从数据库查出来的）可以是一个以“,”隔开的字符串或数组。   $form->listbox($column[, $label])->options([1 => 'foo', 2 => 'bar', 'val' => 'Option name']);"},{"h2":"textarea","h3":"","h4":"","name":"textarea","content":"$form->textarea($column[, $label])->rows(10);"},{"h2":"radio","h3":"","h4":"","name":"radio","content":"$form->radio($column[, $label])->options(['m' => 'Female', 'f'=> 'Male'])->default('m'); // 竖排 $form->radio($column[, $label])->options(['m' => 'Female', 'f'=> 'Male'])->stacked();"},{"h2":"checkbox","h3":"","h4":"","name":"checkbox","content":"checkbox能处理两种数据存储情况，参考多选框  options()方法用来设置选择项:  $form->checkbox($column[, $label])->options([1 => 'foo', 2 => 'bar', 'val' => 'Option name']); // 竖排 $form->checkbox($column[, $label])->options([1 => 'foo', 2 => 'bar', 'val' => 'Option name'])->stacked();"},{"h2":"email","h3":"","h4":"","name":"email","content":"$form->email($column[, $label]);"},{"h2":"password","h3":"","h4":"","name":"password","content":"$form->password($column[, $label]);"},{"h2":"url输入框","h3":"","h4":"","name":"url","content":"$form->url($column[, $label]);"},{"h2":"ip","h3":"","h4":"","name":"ip","content":"$form->ip($column[, $label]);"},{"h2":"mobile","h3":"","h4":"","name":"mobile","content":"$form->mobile($column[, $label])->options(['mask' => '999 9999 9999']);"},{"h2":"color","h3":"","h4":"","name":"color","content":"$form->color($column[, $label])->default('#ccc');"},{"h2":"time","h3":"","h4":"","name":"time","content":"$form->time($column[, $label]); // 设置时间格式，更多格式参考http://momentjs.com/docs/#/displaying/format/ $form->time($column[, $label])->format('HH:mm:ss');"},{"h2":"date","h3":"","h4":"","name":"date","content":"$form->date($column[, $label]); // 设置日期格式，更多格式参考http://momentjs.com/docs/#/displaying/format/ $form->date($column[, $label])->format('YYYY-MM-DD');"},{"h2":"datetime","h3":"","h4":"","name":"datetime","content":"$form->datetime($column[, $label]); // 设置日期格式，更多格式参考http://momentjs.com/docs/#/displaying/format/ $form->datetime($column[, $label])->format('YYYY-MM-DD HH:mm:ss');"},{"h2":"timeRange","h3":"","h4":"","name":"timeRange","content":"$startTime、$endTime为开始和结束时间字段:  $form->timeRange($startTime, $endTime, 'Time Range');"},{"h2":"dateRange","h3":"","h4":"","name":"dateRange","content":"$startDate、$endDate为开始和结束日期字段:  $form->dateRange($startDate, $endDate, 'Date Range');"},{"h2":"datetimeRange","h3":"","h4":"","name":"datetimeRange","content":"$startDateTime、$endDateTime为开始和结束时间日期:  $form->datetimeRange($startDateTime, $endDateTime, 'DateTime Range');"},{"h2":"currency","h3":"","h4":"","name":"currency","content":"$form->currency($column[, $label]); // 设置单位符号 $form->currency($column[, $label])->symbol('￥');"},{"h2":"number","h3":"","h4":"","name":"number","content":"$form->number($column[, $label]);"},{"h2":"rate","h3":"","h4":"","name":"rate","content":"$form->rate($column[, $label]);"},{"h2":"file","h3":"","h4":"","name":"file","content":"使用文件上传功能之前需要先完成上传配置。文件上传配置以及内置方法请参考:图片/文件上传.  文件上传目录在文件config/admin.php中的upload.file中配置，如果目录不存在，需要创建该目录并开放写权限。  $form->file($column[, $label]); // 修改文件上传路径和文件名 $form->file($column[, $label])->move($dir, $name); // 并设置上传文件类型 $form->file($column[, $label])->rules('mimes:doc,docx,xlsx'); // 添加文件删除按钮 $form->file($column[, $label])->removable();"},{"h2":"image","h3":"","h4":"","name":"image","content":"使用图片上传功能之前需要先完成上传配置。图片上传配置以及内置方法请参考:图片/文件上传.  图片上传目录在文件config/admin.php中的upload.image中配置，如果目录不存在，需要创建该目录并开放写权限。  可以使用压缩、裁切、添加水印等各种方法,需要先安装intervention/image。  更多使用方法请参考[Intervention]：  $form->image($column[, $label]); // 修改图片上传路径和文件名 $form->image($column[, $label])->move($dir, $name); // 剪裁图片 $form->image($column[, $label])->crop(int $width, int $height, [int $x, int $y]); // 加水印 $form->image($column[, $label])->insert($watermark, 'center');"},{"h2":"multipleImage/multipleFile","h3":"","h4":"","name":"multipleImage","content":"多图片上传表单继承自单图上传表单，多文件上传表单继承自单文件上传表单。   注入这个字段的数据（从数据库查出来的）可以是一个以“,”隔开的字符串或数组。   // 多图 $form->multipleImage($column[, $label]); // 限制最大上传数量 $form->multipleImage($column[, $label])->limit(3); // 多文件 $form->multipleFile($column[, $label]); // 限制最大上传数量 $form->multipleFile($column[, $label])->limit(5);  多图/文件上传的时候提交的数据为以“,”隔开的文件路径字符串。当然你可以通过以下方式把数据在保存进数据库之前改为你想要的格式：  // 转化为json格式保存到数据库 $form->multipleFile($column[, $label])->customPrepare(function ($paths) { $paths = Helper::array($paths); return json_encode($paths); }); "},{"h2":"map","h3":"","h4":"","name":"map","content":"地图组件引用了网络资源，默认关闭,如果要开启这个组件参考form组件管理  地图控件，用来选择经纬度,$latitude, $longitude为经纬度字段，Laravel的locale设置为zh_CN的时候使用腾讯地图，否则使用Google地图：  $form->map($latitude, $longitude, $label);"},{"h2":"slider","h3":"","h4":"","name":"slider","content":"可以用来数字类型字段的选择，比如年龄：  $form->slider($column[, $label])->options(['max' => 100, 'min' => 1, 'step' => 1, 'postfix' => 'years old']);  更多options请参考:https://github.com/IonDen/ion.rangeSlider#settings"},{"h2":"editor","h3":"","h4":"","name":"editor","content":"编辑器组件引用了网络资源，默认关闭,如果要开启这个组件参考form组件管理.  $form->editor($column[, $label]);"},{"h2":"hidden","h3":"","h4":"","name":"hidden","content":"$form->hidden($column);"},{"h2":"switch","h3":"","h4":"","name":"switch","content":"开关表单保存到数据库的默认值  $form->switch($column[, $label]);"},{"h2":"display","h3":"","h4":"","name":"display","content":"只显示字段，不做任何操作：  $form->display($column[, $label]); //更复杂的显示 $form->display($column[, $label])->with(function ($value) { return \"<img src=\"$value\" />\"; });"},{"h2":"divider","h3":"","h4":"","name":"divider","content":"$form->divider();"},{"h2":"html","h3":"","h4":"","name":"html","content":"插入html内容，参数可以是实现了Htmlable、Renderable或者实现了__toString()方法的类  $form->html('你的html内容', $label = '');"},{"h2":"tags","h3":"","h4":"","name":"tags","content":"插入逗号(,)隔开的字符串tags  $form->tags('keywords');  tags同样支持ManyToMany的关系，示例如下：  $form->tags('tags', '文章标签') ->pluck('name', 'id') // name 为需要显示的 Tag 模型的字段，id 为主键 ->options(Tag::all());// 下拉框选项  注意：处理ManyToMany关系时必须调用pluck方法，指定显示的字段名和主键。 此外 options 方法传入一个Collection对象时，options会自动调用该对象的pluck方法转为['主键名' => '显示字段名'] 数组，作为下拉框选项。或者可以直接使用['主键名' => '显示字段名']这样的数组作为参数。  tags还支持saving方法用于处理提交的数据，示例如下：  $form->tags('tags', '文章标签') ->pluck('name', 'id') ->options(Tag::all()) ->saving(function ($value) { return $value; });  saving 方法接收一个「参数为 tags 的提交值，返回值为修改后的 tags 提交值」的闭包，可以用于实现自动创建新 tag 或其它功能。"},{"h2":"icon","h3":"","h4":"","name":"icon","content":"选择font-awesome图标  $form->icon('icon');"},{"h2":"tree","h3":"","h4":"","name":"tree","content":"树形结构表单  $form->tree('permissions') ->nodes($permissionModel->allNodes()) // 设置所有节点 ->customFormat(function ($v) { // 格式化外部注入的值 if (!$v) return []; return array_column($v, 'id'); }); // 修改节点的字段名称 // 默认 “id” “name” “parent_id” $form->tree('permissions') ->nodes($permissionModel->allNodes()) ->columnNames('id', 'title', 'parent'); // 默认是不保存父节点的值的，因为一般来说父节点只是作为标题的形式存在 // 禁止过滤父节点的值 $form->tree('permissions') ->nodes($permissionModel->allNodes()) ->disableFilterParents();"},{"h2":"table","h3":"","h4":"","name":"table","content":"如果某一个字段存储的是json格式的二维数组，可以使用table表单组件来实现快速的编辑：  $form->table('extra', function (NestedForm $table) { $table->text('key'); $table->text('value'); $table->text('desc'); });  同时在模型里面给这个字段增加访问器和修改器:  public function getExtraAttribute($extra) { return array_values(json_decode($extra, true) ?: []); } public function setExtraAttribute($extra) { $this->attributes['extra'] = json_encode(array_values($extra)); }  这个组件类似于hasMany组件，不过是用来处理单个字段的情况，适用于简单的二维数据。"},{"h2":"一对多","h3":"","h4":"","name":"onemany","content":"一对多内嵌表格，用于处理一对多的关系，下面是个简单的例子：  有两张表是一对多关系：  CREATE TABLE `demo_painters` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `username` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `bio` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; CREATE TABLE `demo_paintings` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `painter_id` int(10) unsigned NOT NULL, `title` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `body` text COLLATE utf8_unicode_ci NOT NULL, `completed_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', PRIMARY KEY (`id`), KEY painter_id (`painter_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;  表的模型为：  <?php namespace App\\Models\\Demo; use Illuminate\\Database\\Eloquent\\Model; class Painter extends Model { public function paintings() { return $this->hasMany(Painting::class, 'painter_id'); } }  <?php namespace App\\Models\\Demo; use Illuminate\\Database\\Eloquent\\Model; class Painting extends Model { protected $fillable = ['title', 'body', 'completed_at']; public function painter() { return $this->belongsTo(Painter::class, 'painter_id'); } }  构建表单代码如下：  $form->display('id', 'ID'); $form->text('username')->rules('required'); $form->textarea('bio')->rules('required'); $form->hasMany('paintings', function (Form\\NestedForm $form) { $form->text('title'); $form->image('body'); $form->datetime('completed_at'); }); $form->display('created_at', 'Created At'); $form->display('updated_at', 'Updated At'); // 也可以设置label $form->hasMany('paintings', '画作', function (Form\\NestedForm $form) { });"},{"h2":"内嵌","h3":"","h4":"","name":"embeds","content":"用于处理mysql的JSON类型字段数据或者mongodb的object类型数据，也可以将多个field的数据值以JSON字符串的形式存储在mysql的字符串类型字段中  比如orders表中的JSON或字符串类型的extra字段，用来存储多个field的数据，先定义model:  class Order extends Model { protected $casts = [ 'extra' => 'json', ]; }  然后在form中使用：  $form->embeds('extra', function ($form) { $form->text('extra1')->rules('required'); $form->email('extra2')->rules('required'); $form->mobile('extra3'); $form->datetime('extra4'); $form->dateRange('extra5', 'extra6', '范围')->rules('required'); }); // 自定义标题 $form->embeds('extra', '附加信息', function ($form) { ... });  回调函数里面构建表单元素的方法调用和外面是一样的。"}]},{"title":"表单初始化","link":"model-form-init","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"通过Form::resolving方法设置的回调函数会在Dcat\\Admin\\Form类被实例化时触发； 通过Form::composing方法设置的回调函数会在render()方法被调用时触发； 开发者可以在这两个事件中改变Form的一些设置或行为，比如需要禁用掉某些操作，可以在app/Admin/bootstrap.php加入下面的代码： use Dcat\\Admin\\Form; Form::resolving(function (Form $form) { $form->disableEditingCheck(); $form->disableCreatingCheck(); $form->disableViewCheck(); $form->tools(function (Form\\Tools $tools) { $tools->disableDelete(); $tools->disableView(); $tools->disableList(); }); }); 这样就不用在每一个控制器的代码中来设置了。 如果全局设置后，要在其中某一个表单中开启设置，比如开启显示继续编辑的checkbox，在对应的实例上调用$form->disableEditingCheck(false);就可以了"}]},{"title":"表单弹窗","link":"model-form-modal","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"通过Form::modal方法可以快速构建一个表单弹窗，仅需增加数行代码。 表单弹窗的实现原理是：通过create和edit页面获取构建好的表单HTML字符，然后使用弹窗插件把这部分HTML字符渲染出来。 如果期间需要加载新的js脚本，则会等待脚本加载完毕再执行表单初始化js代码。 "},{"h2":"简单示例","h3":"","h4":"开启表单弹窗","name":"开启表单弹窗-h4","content":"<?php use App\\Http\\Controllers\\Controller; use Dcat\\Admin\\Form; use Dcat\\Admin\\Layout\\Content; class ModalFormController extends Controller { public function index(Content $content) { return $content ->header('Modal Form') ->body($this->build()); } protected function build() { Form::modal('新增角色') ->click('.create-form') // 绑定点击按钮 ->url('auth/roles/create') // 表单页面链接，此参数会被按钮中的 “data-url” 属性替换。。 ->width('700px') // 指定弹窗宽度，可填写百分比，默认 720px ->height('650px') // 指定弹窗高度，可填写百分比，默认 690px ->success('LA.reload()') // 新增成功后刷新页面 ->render(); Form::modal('编辑角色') ->click('.edit-form') ->success('LA.reload()') // 编辑成功后刷新页面 ->render(); // 当需要在同个“class”的按钮中绑定不同的链接时，把链接放到按钮的“data-url”属性中即可 $editPage = admin_base_path('auth/roles/1/edit'); return \" <div style='padding:30px 0'> <span class='btn btn-success create-form'> 新增表单弹窗 </span> &nbsp;&nbsp; <span class='btn btn-blue edit-form' data-url='{$editPage}'> 编辑表单弹窗 </span> </div> \"; } }"},{"h2":"简单示例","h3":"","h4":"表单构建以及保存数据","name":"表单构建以及保存数据-h4","content":"<?php use App\\Admin\\Repositories\\Role; use Dcat\\Admin\\Controllers\\HasResourceActions; use Dcat\\Admin\\Form; use Dcat\\Admin\\Layout\\Content; use Dcat\\Admin\\Admin; class RoleController { use HasResourceActions; /** * Edit interface. * * @param mixed $id * @param Content $content * * @return Content */ public function edit($id, Content $content) { return $content ->header(trans('admin.roles')) ->description(trans('admin.edit')) ->body($this->form()->edit($id)); } /** * Create interface. * * @param Content $content * * @return Content */ public function create(Content $content) { return $content ->header(trans('admin.roles')) ->description(trans('admin.create')) ->body($this->form()); } /** * Make a form builder. * * @return Form */ protected function form() { return Admin::form(new Role, function (Form $form) { $form->display('id', 'ID'); $form->text('slug', trans('admin.slug'))->required()->prepareForSave(function ($value) { return $value; }); $form->text('name', trans('admin.name'))->required(); $form->tree('permissions') ->nodes(function () { $permissionModel = config('admin.database.permissions_model'); $permissionModel = new $permissionModel; return $permissionModel->allNodes(); }) ->customFormat(function ($v) { if (!$v) return []; return array_column($v, 'id'); }); $form->display('created_at', trans('admin.created_at')); $form->display('updated_at', trans('admin.updated_at')); }); } }"},{"h2":"功能接口","h3":"","h4":"","name":"功能接口-h2","content":"表单弹窗必须绑定一个可点击的页面元素，通过点击这个元素弹出弹窗。"},{"h2":"功能接口","h3":"","h4":"设置弹窗标题","name":"设置弹窗标题-h4","content":"$modal = Form::modal('标题');"},{"h2":"功能接口","h3":"","h4":"绑定点击按钮","name":"绑定点击按钮-h4","content":"通过ModalForm::click方法可以绑定点击按钮，绑定后当点击该按钮时会弹出弹窗  Form::modal('标题') ->click('#click-button');"},{"h2":"功能接口","h3":"","h4":"设置URL","name":"设置URL-h4","content":"如果是创建类型的表单，则可以通过以下方法设置获取表单模板的url  Form::modal('新增角色') ->click('.create-form') ->url('auth/roles/create');  如果是编辑类型的表单，则需要多个url，因为点击每个按钮弹出弹窗的表单内容是不同的，所以每个按钮的链接也不同。  这个时候通过ModalForm::url方法设置的一个链接已经无法满足需求了，因而需要在点击按钮的data-url属性上保存url：  Form::modal('编辑角色') ->click('.edit-form') ->success('LA.reload()') // 编辑成功后刷新页面 ->render(); // 当需要在同个“class”的按钮中绑定不同的链接时，把链接放到按钮的“data-url”属性中即可 $editPage1 = admin_base_path('auth/roles/1/edit'); $editPage2 = admin_base_path('auth/roles/2/edit'); return \" <div style='padding:30px 0'> <span class='btn btn-blue edit-form' data-url='{$editPage1}'> 编辑表单弹窗1 </span> <span class='btn btn-blue edit-form' data-url='{$editPage2}'> 编辑表单弹窗2 </span> </div> \";"},{"h2":"功能接口","h3":"","h4":"表单保存成功回调","name":"表单保存成功回调-h4","content":"通过success方法可以设置表单保存成功之后执行的js代码，在这段js代码作用域内有一个response变量，通过这个变量可以获取服务端返回的json数据。  Form::modal('编辑角色') ->click('.edit-form') ->success( <<<JS // 打印服务端响应数据 console.log(response); // 提示成功信息 LA.success(response.message || '保存成功'); // 保存成功之后刷新页面 LA.reload(); JS ) ->render();"},{"h2":"功能接口","h3":"","h4":"表单保存失败回调","name":"表单保存失败回调-h4","content":"通过error方法可以设置表单保存失败之后执行的js代码，在这段js代码作用域内有一个response变量，通过这个变量可以获取服务端返回的json数据。  Form::modal('编辑角色') ->click('.edit-form') ->error( <<<JS // 打印服务端响应数据 console.log(response); JS ) ->render();"},{"h2":"功能接口","h3":"","h4":"表单保存之后回调","name":"表单保存之后回调-h4","content":"通过saved方法可以设置表单保存之后执行的js代码，在这段js代码作用域内有两个js变量：   success 值为真表示保存成功，否则失败 response 服务端返回的json数据   Form::modal('编辑角色') ->click('.edit-form') ->saved( <<<JS // 打印服务端响应数据 console.log(response); if (success) { console.log('保存成功'); } else { console.log('保存失败'); } JS ) ->render();"},{"h2":"功能接口","h3":"","h4":"强制刷新","name":"强制刷新-h4","content":"每次点击按钮都重新从服务端拉取新的模板数据  Form::modal('编辑角色') ->click('.edit-form') ->forceRefresh() ->render();"},{"h2":"功能接口","h3":"","h4":"设置弹窗宽高","name":"设置弹窗宽高-h4","content":"Form::modal('编辑角色') ->click('.edit-form') ->dimensions('50%', '400px') ->render(); // 或 Form::modal('编辑角色') ->click('.edit-form') ->width('50%') ->height('400px') ->render();"}]},{"title":"分步表单","link":"model-form-step","nodes":[{"h2":"简单示例","h3":"","h4":"","name":"简单示例-h2","content":"protected function form() { $form = new Form(); $form->setTitle('分步表单'); $form->setAction('step'); $form->disableListButton(); $form->multipleSteps() ->remember() ->width('950px') ->add('基本信息', function (Form\\StepForm $step) { $info = '<i class=\"fa fa-exclamation-circle\"></i> 表单字段支持前端验证和后端验证混用，前端验证支持H5表单验证以及自定义验证。'; $step->html(Alert::make($info)->info()); $step->text('name', '姓名')->required()->maxLength(20); // h5 表单验证 $step->text('age', '年龄') ->required() ->type('number') ->attribute('max', 150) ->help('前端验证'); $step->radio('sex', '性别')->options(['未知', '男', '女'])->default(0); // 后端验证 $step->text('birthplace', '籍贯') ->rules('required') ->help('演示后端字段验证'); $step->url('homepage', '个人主页'); $step->textarea('description', '简介'); }) ->add('兴趣爱好', function (Form\\StepForm $step) { $step->tags('hobbies', '爱好') ->options(['唱', '跳', 'RAP', '踢足球']) ->required(); $step->text('books', '书籍'); $step->text('music', '音乐'); // 事件 $step->shown(function () { return <<<JS LA.info('兴趣爱好'); console.log('兴趣爱好', args); JS; }); }) ->add('地址', function (Form\\StepForm $step) { $step->text('address', '街道地址'); $step->text('post_code', '邮政编码'); $step->tel('tel', ' 联系电话'); }) ->done(function () use ($form) { $resource = $form->getResource(0); $data = [ 'title' => '操作成功', 'description' => '恭喜您成为第10086位用户', 'createUrl' => $resource, 'backUrl' => $resource, ]; return view('admin::form.done-step', $data); }); return $form; }  效果"},{"h2":"运行逻辑","h3":"","h4":"","name":"运行逻辑-h2","content":"分步表单的使用很简单，运行逻辑也与普通表单没有太大区别，下面简单说说分步表单的运行逻辑。   分步表单没有 update 的概念。 "},{"h2":"运行逻辑","h3":"","h4":"参数验证","name":"参数验证-h4","content":"当用户点击 下一步 时，会向后端发起请求验证参数是否正确，如果参数不符合要求则显示错误信息，验证通过才会进入下一个步骤。"},{"h2":"运行逻辑","h3":"","h4":"表单提交","name":"表单提交-h4","content":"当进行到最后一步时，会对所有步骤的表单参数一起提交到后端并进行验证，如果参数不符合要求则显示错误信息，验证通过则保存表单数据，保存的方法与普通表单完全一致。   最后保存表单的方法是 Form::store。 "},{"h2":"运行逻辑","h3":"","h4":"完成页面","name":"完成页面-h4","content":"表单保存完成之后会显示完成页面，此步骤无法忽略。"},{"h2":"功能接口","h3":"设置容器最大宽度","h4":"","name":"设置容器最大宽度-h3","content":"默认 1000px。   此方法只针对大屏幕，手机端页面会自动调节大小。   $form->multipleSteps()->width('900px');"},{"h2":"功能接口","h3":"记住表单数据","h4":"","name":"记住表单数据-h3","content":"开启此功能之后，当用户点击 下一步 按钮并且参数验证通过后，会把表单数据保存在 session 中，直到整个分步表单保存完毕之后才会销毁。   此功能默认不开启。   // 开启 $form->multipleSteps()->remember(); // 关闭 $form->multipleSteps()->remember(false);"},{"h2":"功能接口","h3":"设置容器间距","h4":"","name":"设置容器间距-h3","content":"默认值 30px 18px 30px。  $form->multipleSteps()->padding('30px 18px 30px');"},{"h2":"功能接口","h3":"监听页面离开事件","h4":"","name":"监听页面离开事件-h3","content":"监听所有步骤表单页面离开事件，可添加多个。  $form->multipleSteps()->leaving(<<<JS // 获取当前页面的步骤索引 var index = args.index; LA.info(\"你将要离开第 \" + (index + 1) + \" 个页面\"); // args变量是一个js对象，包含当前事件对象、当前步骤选项、表单对象和表单值等字段。 console.log(\"leaving\", args); // 获取当前事件对象 var evt = args.event; // 获取步骤表单标题tap对象 var tab = args.tab; // 获取动向是前往上一步还是下一步页面：\"forward\"、\"backward\" var direction = args.direction; // 获取当前步骤的表单JQ对象 var $form = args.form; // 获取当前步骤页的表单值 var formArray = args.formArray; // 获取指定步骤的表单JQ对象 var $firstForm = args.getForm(0); // 获取指定步骤的表单值 var firstFormArray = args.getFormArray(0); // 停止离开当前页面 return false; JS )->leaving(...);"},{"h2":"功能接口","h3":"监听页面显示事件","h4":"","name":"监听页面显示事件-h3","content":"监听所有步骤表单页面显示事件，可添加多个。  $form->multipleSteps()->shown(<<<JS // 获取当前页面的步骤索引 var index = args.index; LA.info(\"当前显示的是第 \" + (index + 1) + \" 个页面\"); // args变量的值与“leaving”事件的值相同。 console.log(\"shown\", args); JS )->shown(...);"},{"h2":"功能接口","h3":"增加步骤表单","h4":"","name":"增加步骤表单-h3","content":"步骤表单支持所有表单字段。  use Dcat\\Admin\\Form; $form->multipleSteps()->add('标题', function (Form\\StepForm $step) { $step->text('username')->rules('required'); ... });"},{"h2":"功能接口","h3":"增加步骤表单","h4":"监听步骤页面离开事件","name":"监听步骤页面离开事件-h4","content":"监听当前步骤页面离开事件，支持监听多次。  use Dcat\\Admin\\Form; $form->multipleSteps()->add('基本信息', function (Form\\StepForm $step) { ... $step->leaving(<<<JS LA.info(\"你将要离开 基本信息 页面\"); // args变量是一个js对象，包含当前事件对象、当前步骤选项、表单对象和表单值等字段。 console.log(\"离开 基本信息\", args); // 获取当前事件对象 var evt = args.event; // 获取当前页面的步骤索引 var index = args.index; // 获取步骤表单标题tap对象 var tab = args.tab; // 获取动向是前往上一步还是下一步页面：\"forward\"、\"backward\" var direction = args.direction; // 获取当前步骤的表单JQ对象 var $form = args.form; // 获取当前步骤页的表单值 var formArray = args.formArray; // 获取指定步骤的表单JQ对象 var $firstForm = args.getForm(0); // 获取指定步骤的表单值 var firstFormArray = args.getFormArray(0); // 停止离开当前页面 return false; JS ); // 监听多次 $step->leaving(...); });"},{"h2":"功能接口","h3":"增加步骤表单","h4":"监听步骤页面显示事件","name":"监听步骤页面显示事件-h4","content":"监听当前步骤页面显示事件，支持监听多次。  use Dcat\\Admin\\Form; $form->multipleSteps()->add('基本信息', function (Form\\StepForm $step) { ... $step->shown(<<<JS LA.info(\"当前步骤是 基本信息\"); // args变量的值与“leaving”事件的值相同。 console.log(\"显示 基本信息\", args); JS ); // 监听多次 $step->shown(...); });"},{"h2":"功能接口","h3":"设置完成页面","h4":"","name":"设置完成页面-h3","content":"当所有步骤都完成之后会显示完成页面，系统提供一个默认的完成页面，开发者也可以通过以下方法自定义完成页面要显示的内容。  use Dcat\\Admin\\Form; $form->multipleSteps()->done(function (Form\\DoneStep $done) { // 获取新增ID // 由 Repository::store 返回的值 $newId = $done->getNewId(); // 返回你要显示的内容，可以使一个视图也可以是一个字符串。 return view(...); });"}]},{"title":"表单字段翻译","link":"model-form-trans","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"数据表单表单中所有使用到字段的地方都会自动读取语言包中的翻译。 语言包的详细使用方法请参考多语言。 "},{"h2":"","h3":"语言包名称","h4":"","name":"语言包名称-h3","content":"语言包名称需要与控制器名相对应，假如控制器名UserProfileController，则对应的语言包为resources/lang/{当前语言}/user-profile.php（需要转化为小写中划线风格）。"},{"h2":"","h3":"示例","h4":"","name":"示例-h3","content":"现在假设语言包resources/lang/zh-CN/user-profile.php内容如下：  return [ 'fields' => [ 'name' => '名称', 'age' => '年龄', 'class' => '班级', ], ];  控制器UserProfileController中设置的Form字段会自动读取以上翻译：  // 不设置labael会自动读取语言包翻译 $form->display('id'); $form->text('name'); $form->text('age'); $form->text('class');"},{"h2":"","h3":"公共翻译","h4":"","name":"公共翻译-h3","content":"当admin_trans_field函数找不到当前控制器中对指定字段的翻译时，会去global.php中查找。如果某些字段是很多数据表中都有的，可以把这些翻译写在resources/lang/{当前语言}/global.php文件中。  return [ // 常用的字段放在 global.php 中可以所有控制器共用。 'fields' => [ 'id' => 'ID', 'created_at' => '创建时间', 'updated_at' => '更新时间', ], ];"}]},{"title":"图片/文件上传","link":"model-form-upload","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"model-form通过以下的调用来生成form元素，支持本地和云存储的文件上传。 上传组件是基于webuploader实现的，具体的使用配置可参考webuploader官方文档。 $form->file('file_column'); $form->image('image_column');"},{"h2":"本地上传","h3":"","h4":"","name":"local","content":"先添加存储配置，config/filesystems.php 添加一项disk:   'disks' => [ ... , 'admin' => [ 'driver' => 'local', 'root' => public_path('uploads'), 'visibility' => 'public', 'url' => env('APP_URL').'/uploads', ], ],   设置上传的路径为public/uploads(public_path('uploads'))。  然后选择上传的disk，打开config/admin.php找到：   'upload' => [ 'disk' => 'admin', 'directory' => [ 'image' => 'images', 'file' => 'files', ] ],   将disk设置为上面添加的admin，directory.image和directory.file分别为用$form->image($column)和$form->file($column)上传的图片和文件的上传目录。  当然你也可以在代码中指定disk：  $form->file('file')->disk('your disk name');"},{"h2":"云盘上传","h3":"","h4":"","name":"oss","content":"如果需要上传到云存储，需要安装对应laravel storage的适配器，拿七牛云存储举例  首先安装 zgldh/qiniu-laravel-storage  同样配置好disk，在config/filesystems.php 添加一项:  'disks' => [ ... , 'qiniu' => [ 'driver' => 'qiniu', 'domains' => [ 'default' => 'xxxxx.com1.z0.glb.clouddn.com', //你的七牛域名 'https' => 'dn-yourdomain.qbox.me', //你的HTTPS域名 'custom' => 'static.abc.com', //你的自定义域名 ], 'access_key'=> '', //AccessKey 'secret_key'=> '', //SecretKey 'bucket' => '', //Bucket名字 'notify_url'=> '', //持久化处理回调地址 'url' => 'http://of8kfibjo.bkt.clouddn.com/', // 填写文件访问根url ], ],   然后修改dcat-admin的上传配置，打开config/admin.php找到：   'upload' => [ 'disk' => 'qiniu', 'directory' => [ 'image' => 'image', 'file' => 'file', ], ],   disk选择上面配置的qiniu，或：  $form->file('file')->disk('qiniu');"},{"h2":"公共方法","h3":"disk","h4":"","name":"disk","content":"修改文件上传源  $form->file('file')->disk('your disk name');"},{"h2":"公共方法","h3":"move","h4":"","name":"move","content":"修改上传路径  $form->file('file')->move('public/upload/image1/');"},{"h2":"公共方法","h3":"name","h4":"","name":"name","content":"修改上传文件名称  $form->file('file')->name('test.text'); $form->image('picture')->name(function ($file) { return 'test.'.$file->guessExtension(); });"},{"h2":"公共方法","h3":"uniqueName","h4":"","name":"uniqueName","content":"使用随机生成文件名 (md5(uniqid()).extension)  $form->image('picture')->uniqueName();"},{"h2":"公共方法","h3":"storagePermission","h4":"","name":"storagePermission","content":"设置上传文件的权限  $form->image('picture')->storagePermission(777);"},{"h2":"公共方法","h3":"disableRemove","h4":"","name":"disableRemove","content":"禁止删除按钮  // 禁止删除按钮 $form->file($column[, $label])->disableRemove();"},{"h2":"公共方法","h3":"限制上传文件类型","h4":"","name":"accept","content":"限制上传文件的类型  $form->file('file')->accept('jpg,png,gif,jpeg'); // 可以指定 mimeTypes， 多个用逗号分割 $form->file('file')->accept('jpg,png,gif,jpeg', 'image/*');"},{"h2":"公共方法","h3":"disableChunked","h4":"","name":"disableChunked","content":"禁用分块上传  $form->file('file')->disableChunked();"},{"h2":"公共方法","h3":"chunkSize","h4":"","name":"chunkSize","content":"分块大小，单位为“KB”，默认“5MB”  // 设置为 1MB $form->file('file')->chunkSize(1024);"},{"h2":"公共方法","h3":"maxSize","h4":"","name":"maxSize","content":"设置单个文件最大大小，单位为“KB”  $form->file('file')->maxSize(1024);"},{"h2":"公共方法","h3":"threads","h4":"","name":"threads","content":"设置并发上传线程数，默认3  $form->file('file')->threads(5);"},{"h2":"公共方法","h3":"url","h4":"","name":"url","content":"修改文件上传路径，此方法一般不需要修改  $form->file('file')->url('users/upload');"},{"h2":"公共方法","h3":"deleteUrl","h4":"","name":"deleteUrl","content":"修改删除已上传文件路径，此方法一般不需要修改  $form->file('file')->deleteUrl('file/delete');"},{"h2":"公共方法","h3":"disableAutoSave","h4":"","name":"disableAutoSave","content":"禁止上传文件后自动保存文件路径到数据库，此方法一般不需要修改  $form->file('file')->disableAutoSave();"},{"h2":"公共方法","h3":"options","h4":"","name":"options","content":"自定义webuploader配置  $form->file('file')->options(['disableGlobalDnd' => true]);"},{"h2":"图片上传内置方法","h3":"压缩、裁切、添加水印等","h4":"","name":"intervention","content":"可以使用压缩、裁切、添加水印等各种方法,需要先安装intervention/image.  更多使用方法请参考[Intervention]：  $form->image($column[, $label]); // 修改图片上传路径和文件名 $form->image($column[, $label])->move($dir, $name); // 剪裁图片 $form->image($column[, $label])->crop(int $width, int $height, [int $x, int $y]); // 加水印 $form->image($column[, $label])->insert($watermark, 'center');"},{"h2":"图片上传内置方法","h3":"限制上传图片的尺寸","h4":"","name":"dimensions","content":"设置文件上传尺寸限制  参数： array 单位为像素   width 指定宽度 height 指定高度 min_width 最小宽度 min_height 最小高度 max_width 最大宽度 max_height 最大高度 ratio 宽高比 (width/height)   // 上传宽度为100-300像素之间的图片 $form->image('img')->dimensions(['min_width' = 100, 'max_width' => 300]);"}]},{"title":"表单验证","link":"model-form-validation","nodes":[{"h2":"返回自定义验证错误信息","h3":"","h4":"","name":"返回自定义验证错误信息-h2","content":"通过Form::responseValidationMessages方法可以返回自定义验证错误信息，如下：  // 编辑提交时是“PUT”方法 if (request()->getMethod() == 'PUT') { if (...) { // 你的验证逻辑 $form->responseValidationMessages('title', 'title格式错误'); // 如有多个错误信息，第二个参数可以传数组 $form->responseValidationMessages('content', ['content格式错误', 'content不能为空']); } } $form->text('title'); $form->text('content');"},{"h2":"前端验证","h3":"","h4":"","name":"前端验证-h2","content":"系统继承了bootstrap-validator进行前端表单验证，支持H5表单类型的验证。   不支持H5的浏览器也可以使用前端验证，系统已经做好了兼容。大部分表单都支持前端和后端验证，两者可以同时工作不冲突，少部分表单前端验证无效。 "},{"h2":"前端验证","h3":"H5验证","h4":"required","name":"required-h4","content":"必填  $form->text('title')->required();"},{"h2":"前端验证","h3":"H5验证","h4":"number","name":"number-h4","content":"只允许输入数字  $form->text('age')->type('number');  限制范围  // 只允许输入 10-60 范围内的数字 $form->text('age') ->type('number') ->attribute('min', 10) ->attribute('max', 60);"},{"h2":"前端验证","h3":"H5验证","h4":"email","name":"email-h4","content":"邮箱  $form->email('email');"},{"h2":"前端验证","h3":"H5验证","h4":"url","name":"url-h4","content":"链接  $form->text('website')->type('url');"},{"h2":"前端验证","h3":"其它","h4":"minLength","name":"minLength-h4","content":"限制字符最小长度  $form->text('title')->minLength(20); // 设置错误信息 $form->text('title')->minLength(20, '最少输入20个字符');"},{"h2":"前端验证","h3":"其它","h4":"maxLength","name":"maxLength-h4","content":"限制字符最大长度  $form->text('title')->maxLength(50); // 设置错误信息 $form->text('title')->minLength(50, '不能超过50个字符');"},{"h2":"前端验证","h3":"其它","h4":"same","name":"same-h4","content":"限制当前字段值必须与给定字段的值相等，常用于密码确认  $form->password('password'); $form->password('password_confirm')->same('password'); // 设置错误信息 $form->password('password_confirm')->same('password', '两次密码输入不一致');"},{"h2":"前端验证","h3":"自定义","h4":"","name":"自定义-h3","content":"开发者可以通过以下方法自定义前端验证规则。  在 app/Admin/bootstrap.php 中添加以下代码。  use Dcat\\Admin\\Form\\Field; Field\\Text::macro('len', function (int $length, ?string $error = null) { // 前端验证逻辑扩展 Admin::script( <<<'JS' LA.extendValidator('len', function ($el) { return $el.val().length != $el.attr('data-len'); }); JS ); // 同时添加后端验证逻辑，这个可以看需要 $this->rules('size:'.$length); return $this->attribute([ 'data-len' => $length, 'data-len-error' => str_replace( [':attribute', ':len'], [$this->label, $length], $error ?: \"只能输入:len个字符\" ), ]); });  使用  $form->text('name')->len(10);"}]},{"title":"表单基本使用","link":"model-form","nodes":[{"h2":"示例","h3":"","h4":"","name":"示例-h2","content":"Dcat\\Admin\\Form类用于快速生成表单页面，先来个例子，数据库中有movies表  CREATE TABLE `movies` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `director` int(10) unsigned NOT NULL, `describe` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `rate` tinyint unsigned NOT NULL, `released` enum(0, 1), `release_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;   对应的数据模型为App\\Models\\Movie，数据仓库为App\\Admin\\Repositories\\Movie：  use App\\Admin\\Repositories\\Movie; use Dcat\\Admin\\Form; use Dcat\\Admin\\Admin; $form = Admin::form(new Movie, function (Form $form) { // 显示记录id $form->display('id', 'ID'); // 添加text类型的input框 $form->text('title', '电影标题'); $directors = [ 1 => 'John', 2 => 'Smith', 3 => 'Kate', ]; $form->select('director', '导演')->options($directors); // 添加describe的textarea输入框 $form->textarea('describe', '简介'); // 数字输入框 $form->number('rate', '打分'); // 添加开关操作 $form->switch('released', '发布？'); // 添加日期时间选择框 $form->dateTime('release_at', '发布时间'); // 两个时间显示 $form->display('created_at', '创建时间'); $form->display('updated_at', '修改时间'); });"},{"h2":"数据仓库","h3":"","h4":"","name":"数据仓库-h2","content":"表单对数据的操作并非直接依赖于Eloquent Model，而是依赖于Repository提供的数据操作接口。具体请参考表单数据源。"},{"h2":"表单定义","h3":"","h4":"","name":"表单定义-h2","content":"推荐使用以下方式构建表单  use App\\Admin\\Repositories\\Movie; use Dcat\\Admin\\Form; use Dcat\\Admin\\Admin; $form = Admin::form(new Movie, function (Form $form) { // 显示记录id $form->display('id', 'ID'); $form->select('director', '导演')->options($directors); ... });"},{"h2":"表单定义","h3":"获取当前模型数据","h4":"","name":"获取当前模型数据-h3","content":"在闭包内可以获取到当前模型的数据（编辑）  Admin::form(new Movie, function (Form $form) { // 显示记录id $form->display('id', 'ID'); // 获取模型数据，如果\"status == 1\"则显示\"rate\"字段 if ($form->model()->status == 1) { $form->number('rate'); } $form->select('director', '导演')->options($directors); ... });"},{"h2":"表单定义","h3":"获取关联模型数据","h4":"","name":"获取关联模型数据-h3","content":"如果表单的渲染需要获取关联模型的数据，需要在实例化数据仓库时传入模型上设置的关联名称  // 关联\"permissions\" return Admin::form(new Role('permissions'), function (Form $form) { $form->display('id', 'ID'); $form->text('slug', trans('admin.slug'))->required(); $form->text('name', trans('admin.name'))->required(); $form->tree('permissions') ->nodes(function () { $permissionModel = config('admin.database.permissions_model'); $permissionModel = new $permissionModel; return $permissionModel->allNodes(); }) ->customFormat(function ($v) { if (!$v) return []; return array_column($v, 'id'); }); ... });"},{"h2":"自定义工具","h3":"","h4":"","name":"自定义工具-h2","content":"表单右上角默认有返回和跳转列表两个按钮工具, 可以使用下面的方式修改它:  $form->tools(function (Form\\Tools $tools) { // 去掉跳转列表按钮 $tools->disableList(); // 去掉跳转详情页按钮 $tools->disableView(); // 去掉删除按钮 $tools->disableDelete(); // 添加一个按钮, 参数可以是字符串, 匿名函数, 或者实现了Renderable或Htmlable接口的对象实例 $tools->add('<a class=\"btn btn-sm btn-danger\"><i class=\"fa fa-trash\"></i>&nbsp;&nbsp;delete</a>'); }); // 去除整个工具栏内容 $form->disableHeader(); // 也可以通过以下方式去除工具栏的默认按钮 $form->disableListButton(); $form->disableViewButton(); $form->disableDeleteButton(); "},{"h2":"表单底部","h3":"","h4":"","name":"表单底部-h2","content":"使用下面的方法去掉form底部的元素  $form->footer(function ($footer) { // 去掉`重置`按钮 $footer->disableReset(); // 去掉`提交`按钮 $footer->disableSubmit(); // 去掉`查看`checkbox $footer->disableViewCheck(); // 去掉`继续编辑`checkbox $footer->disableEditingCheck(); // 去掉`继续创建`checkbox $footer->disableCreatingCheck(); }); // 去除整个底部内容 $form->disableFooter(); // 也可以通过以下方式去底部元素 $form->disableSubmitButton(); $form->disableResetButton(); $form->disableViewCheck(); $form->disableEditingCheck(); $form->disableCreatingCheck();"},{"h2":"其它方法","h3":"","h4":"设置外层容器","name":"设置外层容器-h4","content":" // 更改表格外层容器 $form->wrap(function (Renderable $view) { $tab = Tab::make(); $tab->add('示例', $view); $tab->add('代码', $this->code(), true); return $tab; });"},{"h2":"其它方法","h3":"","h4":"去掉提交按钮:","name":"去掉提交按钮:-h4","content":"$form->disableSubmitButton();"},{"h2":"其它方法","h3":"","h4":"去掉重置按钮:","name":"去掉重置按钮:-h4","content":"$form->disableResetButton();"},{"h2":"其它方法","h3":"","h4":"忽略掉不需要保存的字段","name":"忽略掉不需要保存的字段-h4","content":"$form->ignore(['column1', 'column2', 'column3']); // 取消已忽略的字段 $form->removeIgnoredFields(['column1',]);"},{"h2":"其它方法","h3":"","h4":"设置宽度","name":"设置宽度-h4","content":"$form->setWidth(10, 2);"},{"h2":"其它方法","h3":"","h4":"设置表单提交的action","name":"设置表单提交的action-h4","content":"$form->setAction('admin/users');"},{"h2":"其它方法","h3":"","h4":"判断是否是新增","name":"判断是否是新增-h4","content":"新增页面和保存新增数据都可以用这个方法判断  if ($form->isCreating()) { ... }"},{"h2":"其它方法","h3":"","h4":"判断是否是编辑","name":"判断是否是编辑-h4","content":"编辑页面和保存编辑数据都可以用这个方法判断  if ($form->isEditing()) { ... }"},{"h2":"其它方法","h3":"","h4":"判断是否是删除","name":"判断是否是删除-h4","content":"if ($form->isDeleting()) { ... }"},{"h2":"其它方法","h3":"","h4":"获取ID","name":"获取ID-h4","content":"新增页面无效  return Admin::form(new User, function (Form $form) { $id = $form->getKey(); ... });"},{"h2":"其它方法","h3":"","h4":"获取表单提交的数据","name":"获取表单提交的数据-h4","content":"$form->saving(function (Form $form) { $username = $form->username; // 等同于 $username = $form->input('username'); });"},{"h2":"其它方法","h3":"","h4":"修改或删除表单提交的数据","name":"修改或删除表单提交的数据-h4","content":"$form->saving(function (Form $form) { // 修改 $username = $form->input('username', 'Marry'); // 删除 $form->deleteInput('username'); });"},{"h2":"其它方法","h3":"","h4":"获取最终保存的数据","name":"获取最终保存的数据-h4","content":"此方法仅在saved回调有效。  $form->saved(function (Form $form) { $data = $form->getUpdates(); });"},{"h2":"其它方法","h3":"","h4":"页面跳转","name":"redirect","content":"跳转到指定页面，此方法仅在表单回调事件内可用  // 跳转并提示成功信息 $form->saved(function (Form $form) { return $form->redirect('auth/user', '保存成功'); }); // 跳转并提示错误信息 $form->creating(function (Form $form) { return $form->redirect('auth/user', [ 'message' => '系统错误', 'status' => false, ]); });"},{"h2":"关联模型","h3":"一对一","h4":"","name":"一对一-h3","content":"users表和profiles表通过profiles.user_id字段生成一对一关联  CREATE TABLE `users` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `email` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; CREATE TABLE `profiles` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `user_id` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `age` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `gender` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;  对应的数据模分别为:  class User extends Model { public function profile() { return $this->hasOne(Profile::class); } } class Profile extends Model { public function user() { return $this->belongsTo(User::class); } }  对应的数据仓库为：  <?php namespace App\\Admin\\Repositories; use Dcat\\Admin\\Repositories\\EloquentRepository; use User as UserModel; class User extends \\Dcat\\Admin\\Repositories\\EloquentRepository { protected $eloquentClass = UserModel::class; }  通过下面的代码可以关联在一个form里面:   实例化数据仓库时需要传入关联模型定义的关联名称，相当于主动使用Eloquent\\Model::with方法。   use App\\Admin\\Repositories\\User; // 注意这里实例化`User`时必须传入\"profile\"，否则将无法关联profiles表数据 $form = Admin::form(new User('profile'), function (Form $form) { $form->display('id'); $form->text('name'); $form->text('email'); $form->text('profile.age'); $form->text('profile.gender'); $form->datetime('created_at'); $form->datetime('updated_at'); }); "}]},{"title":"行的使用和扩展","link":"model-grid-actions","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"model-grid默认有四个行操作编辑、快捷编辑、删除和详情，可以通过下面的方式关闭它们： $grid->actions(function ($actions) { $actions->disableDelete(); $actions->disableEdit(); $actions->disableQuickEidt(); $actions->disableView(); }); // 或 $grid->disableDeleteButton(); $grid->disableEditButton(); $grid->disableQuickEditButton(); $grid->disableViewButton(); 可以通过传入的$actions参数来获取当前行的数据： $grid->actions(function ($actions) { // 当前行的数据数组 $actions->row; // 当前行的某个字段的数据 $actions->row->email; // 获取当前行主键值 $actions->getKey(); }); 如果有自定义的操作按钮，可以通过下面的方式添加： $grid->actions(function ($actions) { // append一个操作 $actions->append('<a href=\"\"><i class=\"fa fa-eye\"></i></a>'); // prepend一个操作 $actions->prepend('<a href=\"\"><i class=\"fa fa-paper-plane\"></i></a>'); } 如果有比较复杂的操作，可以参考下面的方式： 先定义操作类 <?php namespace App\\Admin\\Extensions; use Dcat\\Admin\\Admin; use Illuminate\\Contracts\\Support\\Renderable; class CheckRow implements Renderable { protected $id; public function __construct($id) { $this->id = $id; } protected function script() { return <<<JS $('.grid-check-row').on('click', function () { // Your code. console.log($(this).data('id')); }); JS; } public function render() { Admin::script($this->script()); return \"<a class='btn btn-xs btn-success fa fa-check grid-check-row' data-id='{$this->id}'></a>\"; } } 然后添加操作： $grid->actions(function ($actions) { // 添加操作 $actions->append(new CheckRow($actions->getKey())); }"}]},{"title":"列的显示和扩展","link":"model-grid-column-display","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"model-grid内置了很多对于列的操作方法，可以通过这些方法很灵活的操作列数据。"},{"h2":"列显示","h3":"","h4":"","name":"列显示-h2","content":"model-grid内置了若干方法来帮助你扩展列功能"},{"h2":"列显示","h3":"display","h4":"","name":"display-h3","content":"Dcat\\Admin\\Grid\\Column对象内置了display()方法来通过传入的回调函数来处理当前列的值，  $grid->column('title')->display(function ($title) { return \"<span style='color:blue'>$title</span>\"; });  在传入的匿名函数中可以通过任何方式对数据进行处理，另外匿名函数绑定了当前列的数据作为父对象，可以在函数中调用当前行的数据：  $grid->first_name(); $grid->last_name(); // 不存在的`full_name`字段 $grid->column('full_name')->display(function () { return $this->first_name . ' ' . $this->last_name; });"},{"h2":"列显示","h3":"设置列的HTML属性","h4":"","name":"设置列的HTML属性-h3","content":"设列的html属性  $grid->name->setAttributes(['style' => 'font-size:14px']);"},{"h2":"列显示","h3":"列视图","h4":"","name":"列视图-h3","content":"view方法可以引入一个视图文件。  $grid->content->view('admin.fields.content');  默认会传入视图的三个变量：   $model 当前行数据 $name 字段名称 $value 为当前列的值   模板代码如下：  <label>名称：{{ $name }}</label> <label>值：{{ $value }}</label> <label>其他字段：{{ $model->title }}</label>"},{"h2":"列显示","h3":"列编辑","h4":"","name":"列编辑-h3","content":"通过editable.js的帮助，可以让你在表格中直接编辑数据，使用方法如下  $grid->title()->editable(); $grid->title()->editable('textarea'); $grid->title()->editable('select', [1 => 'option1', 2 => 'option2', 3 => 'option3']); // select 支持传递闭包作为参数，该闭包接收参数为当前行对应的模型 $grid->title()->editable('select', function($row) { if ($row->title === 'test') { return ['test1', 'test2']; } return ['test3', 'test4']; }); $grid->birth()->editable('date'); $grid->published_at()->editable('datetime'); $grid->year->editable('year'); $grid->month->editable('month'); $grid->day->editable('day'); "},{"h2":"列显示","h3":"开关","h4":"","name":"开关-h3","content":" 注意：在grid中对某字段设置switch默认的保存结果是0或1，如需保存其他值请在Model、Repository或Form中修改。   快速将列变成开关组件，使用方法如下：  $grid->status()->switch();"},{"h2":"列显示","h3":"开关组","h4":"","name":"开关组-h3","content":" 注意：在grid中对某字段设置switchGroup默认的保存结果是0或1，如需保存其他值请在Model、Repository或Form中修改。   快速将列变成开关组件组，使用方法如下：  $grid->switch_group->switchGroup([ 'hot' => '热门', 'new' => '最新', 'recommend' => '推荐', 'image.show' => '显示图片', // 更新对应关联模型 ]); // 或 // 不写label会自动从翻译文件翻译，具体使用请参照“字段翻译”章节 $grid->switch_group->switchGroup(['is_new', 'is_hot', 'published']);"},{"h2":"列显示","h3":"下拉选框","h4":"","name":"下拉选框-h3","content":"$grid->options()->select([ 1 => 'Sed ut perspiciatis unde omni', 2 => 'voluptatem accusantium doloremque', 3 => 'dicta sunt explicabo', 4 => 'laudantium, totam rem aperiam', ]);  select 也支持参数为闭包，使用方法和editable的select类似。"},{"h2":"列显示","h3":"单选框","h4":"","name":"单选框-h3","content":"$grid->options()->radio([ 1 => 'Sed ut perspiciatis unde omni', 2 => 'voluptatem accusantium doloremque', 3 => 'dicta sunt explicabo', 4 => 'laudantium, totam rem aperiam', ]);  radio 也支持参数为闭包，使用方法和editable的select类似。"},{"h2":"列显示","h3":"多选框","h4":"","name":"多选框-h3","content":"$grid->options()->checkbox([ 1 => 'Sed ut perspiciatis unde omni', 2 => 'voluptatem accusantium doloremque', 3 => 'dicta sunt explicabo', 4 => 'laudantium, totam rem aperiam', ]);  checkbox 也支持参数为闭包，使用方法和editable的select类似。 "},{"h2":"列显示","h3":"图片","h4":"","name":"图片-h3","content":"$grid->picture()->image(); //设置服务器和宽高 $grid->picture()->image('http://xxx.com', 100, 100); // 显示多图 $grid->pictures()->display(function ($pictures) { return json_decode($pictures, true); })->image('http://xxx.com', 100, 100);"},{"h2":"列显示","h3":"显示label标签","h4":"","name":"显示label标签-h3","content":"$grid->name()->label(); // 设置颜色，默认`success`,可选`danger`、`warning`、`info`、`primary`、`default`、`success`、`custom`、`purple`、`blue`、`inverse`、`tear` $grid->name()->label('danger'); // 接收数组 $grid->keywords()->label();"},{"h2":"列显示","h3":"显示badge标签","h4":"","name":"显示badge标签-h3","content":"$grid->name()->badge(); // 设置颜色，默认`red`,可选`red`、`yellow`、`aqua`、`green`、`gray`、`custom`、`purple`、`blue`、`inverse`、`tear` $grid->name()->badge('danger'); // 接收数组 $grid->keywords()->badge();"},{"h2":"列显示","h3":"列展开","h4":"","name":"列展开-h3","content":"expand方法可以把内容隐藏，点击按钮的时候显示在表格下一行  $grid->content ->display('详情') // 设置按钮名称 ->expand(function () { // 返回显示的详情 // 这里返回 content 字段内容，并用 Card 包裹起来 $card = new Card(null, $this->content); return \"<div style='padding:10px 10px 0'>$card</div>\"; });  也可以通过以下方式设置按钮  $grid->content->expand(function (Grid\\Displayers\\Expand $expand) { // 设置按钮名称 $expand->button('详情'); // 返回显示的详情 // 这里返回 content 字段内容，并用 Card 包裹起来 $card = new Card(null, $this->content); return \"<div style='padding:10px 10px 0'>$card</div>\"; });"},{"h2":"列显示","h3":"弹出模态框","h4":"","name":"弹出模态框-h3","content":"modal方法可以把内容隐藏，点击按钮的时候显示在表格下一行  $grid->content ->display('查看') // 设置按钮名称 ->modal(function () { $card = new Card(null, $this->content); return \"<div style='padding:10px 10px 0'>$card</div>\"; });"},{"h2":"列显示","h3":"进度条","h4":"","name":"进度条-h3","content":"progressBar进度条  $grid->rate->progressBar(); //设置颜色，默认`primary`,可选`danger`、`warning`、`info`、`primary`、`success` $grid->rate->progressBar('success'); // 设置进度条尺寸和最大值 $grid->rate->progressBar('success', 'sm', 100);"},{"h2":"列显示","h3":"showTreeInDialog","h4":"","name":"showTreeInDialog-h3","content":"showTreeInDialog方法可以把一个带有层级关系的数组呈现为树形弹窗，比如权限就可以用此方法展示  // 查出所有的权限数据 $nodes = (new $permissionModel)->allNodes(); // 传入二维数组（未分层级） $grid->permissions->showTreeInDialog($nodes); // 也可以传入闭包 $grid->permissions->showTreeInDialog(function (Grid\\Displayers\\Tree $tree) use (&$nodes, $roleModel) { // 设置所有节点 $tree->nodes($nodes); // 设置节点数据字段名称，默认\"id\"，\"name\"，\"parent_id\" $tree->columnNames('id', 'name', 'parent_id'); // $this->roles 可以获取当前行的字段值 foreach (array_column($this->roles, 'slug') as $slug) { if ($roleModel::isAdministrator($slug)) { // 选中所有节点 $tree->checkedAll(); } } });"},{"h2":"列显示","h3":"内容映射using","h4":"","name":"内容映射using-h3","content":"$grid->status->using([0 => '未激活', 1 => '正常']); // 第二个参数为默认值 $grid->gender->using([1 => '男', 2 => '女'], '未知');"},{"h2":"列显示","h3":"字符串分割为数组","h4":"","name":"字符串分割为数组-h3","content":"explode方法可以把字符串分割为数组。  $grid->tag->explode()->label(); // 可以指定分隔符，默认\",\" $grid->tag->explode('|')->label();"},{"h2":"列显示","h3":"prepend","h4":"","name":"prepend-h3","content":"prepend 方法用于给 string 或 array 类型的值前面插入内容。  // 当字段值是一个字符串 $grid->email->prepend('mailto:'); // 当字段值是一个数组 $grid->arr->prepend('first item');"},{"h2":"列显示","h3":"append","h4":"","name":"append-h3","content":"prepend 方法用于给 string 或 array 类型的值后面插入内容。  // 当字段值是一个字符串 $grid->email->append('@gmail.com'); // 当字段值是一个数组 $grid->arr->append('last item');"},{"h2":"列显示","h3":"列字符串或数组截取","h4":"","name":"列字符串或数组截取-h3","content":"// 最多显示50个字符 $grid->contents->limit(50, '...'); // 如果字段值是数组也支持 $grid->tags->limit(3);"},{"h2":"列显示","h3":"列二维码","h4":"","name":"列二维码-h3","content":"$grid->website->qrcode(function () { return $this->url; }, 200, 200);"},{"h2":"列显示","h3":"可复制","h4":"","name":"可复制-h3","content":"$grid->website->copyable();"},{"h2":"帮助方法","h3":"字符串操作","h4":"","name":"字符串操作-h3","content":"如果当前里的输出数据为字符串，那么可以通过链式方法调用Illuminate\\Support\\Str的方法。  比如有如下一列，显示title字段的字符串值:  $grid->title();  在title列输出的字符串基础上调用Str::title()方法  $grid->title()->title();  调用方法之后输出的还是字符串，所以可以继续调用Illuminate\\Support\\Str的方法：  $grid->title()->title()->ucfirst(); $grid->title()->title()->ucfirst()->substr(1, 10); "},{"h2":"帮助方法","h3":"数组操作","h4":"","name":"数组操作-h3","content":"如果当前列输出的是数组，可以直接链式调用Illuminate\\Support\\Collection方法。  比如tags列是从一对多关系取出来的数组数据：  $grid->tags(); array ( 0 => array ( 'id' => '16', 'name' => 'php', 'created_at' => '2016-11-13 14:03:03', 'updated_at' => '2016-12-25 04:29:35', ), 1 => array ( 'id' => '17', 'name' => 'python', 'created_at' => '2016-11-13 14:03:09', 'updated_at' => '2016-12-25 04:30:27', ), )   调用Collection::pluck()方法取出数组的中的name列  $grid->tags()->pluck('name'); array ( 0 => 'php', 1 => 'python', ),   取出name列之后输出的还是数组，还能继续调用用Illuminate\\Support\\Collection的方法  $grid->tags()->pluck('name')->map('ucwords'); array ( 0 => 'Php', 1 => 'Python', ),  将数组输出为字符串  $grid->tags()->pluck('name')->map('ucwords')->implode('-'); \"Php-Python\""},{"h2":"帮助方法","h3":"混合使用","h4":"","name":"混合使用-h3","content":"在上面两种类型的方法调用中，只要上一步输出的是确定类型的值，便可以调用类型对应的方法，所以可以很灵活的混合使用。  比如images字段是存储多图片地址数组的JSON格式字符串类型：   $grid->images(); // \"['foo.jpg', 'bar.png']\" // 链式方法调用来显示多图 $grid->images()->display(function ($images) { return json_decode($images, true); })->map(function ($path) { return 'http://localhost/images/'. $path; })->image(); "},{"h2":"扩展列的显示功能","h3":"","h4":"","name":"扩展列的显示功能-h2","content":"可以通过两种方式扩展列功能，第一种是通过匿名函数的方式。   扩展列功能方法后IDE默认是不会自动补全的，这时候可以通过php artisan admin::ide-helper生成IDE提示文件，具体请参考IDE自动补全。 "},{"h2":"扩展列的显示功能","h3":"匿名函数","h4":"","name":"匿名函数-h3","content":"在app/Admin/bootstrap.php加入以下代码:  use Dcat\\Admin\\Grid\\Column; // 第二个参数为 `Column` 对象， 第三个参数是自定义参数 Column::extend('color', function ($value, $column, $color) { return \"<span style='color: $color'>$value</span>\" });  然后在model-grid中使用这个扩展：  $grid->title()->color('#ccc');"},{"h2":"扩展列的显示功能","h3":"扩展类","h4":"","name":"扩展类-h3","content":"如果列显示逻辑比较复杂，可以通过扩展类来实现。  扩展类app/Admin/Extensions/Popover.php:  <?php namespace App\\Admin\\Extensions; use Dcat\\Admin\\Admin; use Dcat\\Admin\\Grid\\Displayers\\AbstractDisplayer; class Popover extends AbstractDisplayer { public function display($placement = 'left') { Admin::script(\"$('[data-toggle=\\\"popover\\\"]').popover()\"); return <<<EOT <button type=\"button\" class=\"btn btn-secondary\" title=\"popover\" data-container=\"body\" data-toggle=\"popover\" data-placement=\"$placement\" data-content=\"{$this->value}\" > 弹出提示 </button> EOT; } }  然后在app/Admin/bootstrap.php注册扩展类：  use Dcat\\Admin\\Grid\\Column; use App\\Admin\\Extensions\\Popover; Column::extend('popover', Popover::class);  然后就能在model-grid中使用了：  $grid->desciption()->popover('right');"},{"h2":"扩展列的显示功能","h3":"指定列名","h4":"","name":"指定列名-h3","content":"出了上述两种方式扩展列功能，我们还可以通过指定列名称的方式扩展列功能  在app/Admin/bootstrap.php加入以下代码:  use Dcat\\Admin\\Grid\\Column; // 这个扩展方法等同于 // $grid->title()->display(function ($value) { // return \"<span style='color:red'>$value</span>\" // }); Column::define('title', function ($value) { return \"<span style='color:red'>$value</span>\" }); // 这个扩展方法等同于 // $grid->status()->switch(); Column::define('status', Dcat\\Admin\\Grid\\Displayers\\SwitchDisplay::class);  然后在model-grid中title和status字段会自动使用以上扩展：  $grid->title(); $grid->status();"},{"h2":"根据条件判断是否使用列的显示功能","h3":"","h4":"","name":"根据条件判断是否使用列的显示功能-h2","content":"有些情况我们需要根据某个条件去判断是否使用列的某个显示功能：   需要注意的是，Grid\\Column::if只对列的显示相关功能有效，其他方法如表头的相关操作都不能使用此方法！   $grid->config() ->if(function () { return $this->config ? true : false; }) ->display($view) ->expand($this->getExpandHandler('config')) ->else() ->showEmpty();  上面写法等同于  $grid->config() ->if(function () { return $this->config ? true : false; }) ->then(function (Grid\\Column $column) { $column->display($view)->expand($this->getExpandHandler('config')); }) ->else(function (Grid\\Column $column) { $column->showEmpty(); });  支持多个if  $grid->title ->if(...) ->then(...) ->else(...) ->if(...) ->then(...) ->else(...);"}]},{"title":"列过滤器","link":"model-grid-column-filter","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"这个功能可以给表格的列设置一个过滤器，可以更方便的根据这一列进行数据表格过滤操作"},{"h2":"字符串比较查询","h3":"","h4":"","name":"字符串比较查询-h2","content":"use Dcat\\Admin\\Grid; // WHERE `username` = \"$input\" $grid->username->filter( Grid\\Column\\Filter\\Equal::make() );  上面的调用可以给 username 这一列的头部加上一个 input 类型的过滤器，点击过滤器图标展开过滤器，输入查询提交后，会对这一列执行 等于 查询。"},{"h2":"字符串比较查询","h3":"开启字段值查询","h4":"","name":"开启字段值查询-h3","content":"这个功能可以给每一列字段的值设置一个过滤器，点击该列字段的值就可以进行数据表格过滤操作，非常方便。   开启此功能之后会把这个字段的原始值作为搜索内容，不会受 display 方法影响。   use Dcat\\Admin\\Grid; // 设置为 label 或调用 display 方法不会影响查询内容 $grid->ip->label()->filter(); // 相当于 $grid->ip->filter( Grid\\Column\\Filter\\Equal::make()->valueFilter() );  鼠标移动到开启了值查询功能的列上面，右边会显示一个“放大镜”图标   点击列之后，表头会出现“重置”按钮，点击可以取消筛选"},{"h2":"字符串比较查询","h3":"开启字段值查询","h4":"设置值的字段名称","name":"设置值的字段名称-h4","content":"如果当前列的值并非用户想要搜索的值，可以通过以下方法更改字段名称。  $grid->model()->with('user'); // 实际搜索的会是 name 字段的值 $grid->username->filter('name'); // 二维数组 $grid->user_id->filter('user.id'); // 闭包 $grid->user_id->filter(function () { return $this->user['id']; });"},{"h2":"字符串比较查询","h3":"开启字段值查询","h4":"隐藏表头的筛选器图标","name":"隐藏表头的筛选器图标-h4","content":"use Dcat\\Admin\\Grid; $grid->user_id->filterByValue(); // 相当于 $grid->user_id->filter( Grid\\Column\\Filter\\Equal::make() ->valueFilter() ->hide() );  效果如下"},{"h2":"字符串比较查询","h3":"其余Input表单类型过滤器","h4":"","name":"其余Input表单类型过滤器-h3","content":"use Dcat\\Admin\\Grid; // WHERE `username` LIKE \"%{$input}%\" $grid->username->filter( Grid\\Column\\Filter\\Like::make() ); // WHERE `username` LIKE \"{$input}%\" $grid->username->filter( Grid\\Column\\Filter\\StartWith::make() ); // WHERE `username` > \"$input\" $grid->username->filter( Grid\\Column\\Filter\\Gt::make() ); // WHERE `username` <= \"$input\" $grid->username->filter( Grid\\Column\\Filter\\Ngt::make() ); // WHERE `username` < \"$input\" $grid->username->filter( Grid\\Column\\Filter\\Lt::make() ); // WHERE `username` >= \"$input\" $grid->username->filter( Grid\\Column\\Filter\\Nlt::make() );"},{"h2":"字符串比较查询","h3":"时间日期","h4":"","name":"时间日期-h3","content":"如果字段是时间、日期相关的字段，可以使用下面的方法  use Dcat\\Admin\\Grid; $grid->date()->filter( Grid\\Column\\Filter\\Equal::make()->date() ); $grid->time()->filter( Grid\\Column\\Filter\\Like::make()->time() ); $grid->datetime()->filter( Grid\\Column\\Filter\\Gt::make()->datetime('YYYY-MM-DD HH:mm:ss') );"},{"h2":"多选查询","h3":"","h4":"","name":"多选查询-h2","content":"假设需要在表格数据中通过 status 字段过滤一个或者多个状态的数据，使用多选过滤可以非常方便的实现  use Dcat\\Admin\\Grid; $grid->column('status', '状态')->filter( Grid\\Column\\Filter\\In::make([ 0 => '未知', 1 => '已下单', 2 => '已付款', 3 => '已取消', ]) );"},{"h2":"范围查询","h3":"","h4":"","name":"范围查询-h2","content":"假设需要通过 price 字段过滤出某个价格范围内的数据  $grid->column('price')->filter( Grid\\Column\\Filter\\Between::make() );  或者是时间、日期范围的过滤  use Dcat\\Admin\\Grid; $grid->date()->filter( Grid\\Column\\Filter\\Between::make()->date() ); $grid->time()->filter( Grid\\Column\\Filter\\Between::make()->time() ); $grid->datetime()->filter( Grid\\Column\\Filter\\Between::make()->datetime() );"}]},{"title":"列的基本使用","link":"model-grid-column","nodes":[{"h2":"","h3":"设置列为可排序","h4":"","name":"设置列为可排序-h3","content":"$grid->id()->sortable();"},{"h2":"","h3":"设置列的宽度","h4":"","name":"设置列的宽度-h3","content":"设置列的宽度，当字段内容过长时可以使用这个方法限制列宽度  // px $grid->long_text->width('300px'); // 百分比 $grid->long_text->width('15%');"},{"h2":"","h3":"设置表格头HTML属性","h4":"","name":"设置表格头HTML属性-h3","content":"设标题的html属性  // 修改颜色 $grid->name->setHeaderAttributes(['style' => 'color:#5b69bc']);"},{"h2":"","h3":"设置列的显示或隐藏","h4":"","name":"设置列的显示或隐藏-h3","content":"responsive方法用于启用RWD-Table-Patterns插件，可以在表格右上角控制显示或隐藏当前字段  $grid->email->responsive(); // 0 不可见 // 1 保持可见，但可以在下拉列表筛选隐藏。 // 2 480px 分辨率以下可见 // 3 640px 以下可见 // 4 800px 以下可见 // 5 960px 以下可见 // 6 1120px 以下可见 $grid->name->responsive(2);"},{"h2":"","h3":"设置列的显示或隐藏","h4":"默认隐藏当前列","name":"默认隐藏当前列-h4","content":"// 隐藏字段 $grid->email->hide(); // 相当于 $grid->name->responsive(0);   "},{"h2":"","h3":"设置列提示信息","h4":"","name":"设置列提示信息-h3","content":"Grid\\Column::help参数：   $help string 提示内容 $style string 提示窗背景颜色，支持“primary”、“success”、“danger”、“purple” $placement string 提示窗位置，支持“top”、“left”、“right”、“bottom”   $grid->id()->help('提示信息');"},{"h2":"","h3":"设置列搜索","h4":"","name":"设置列搜索-h3","content":"通过Grid\\Column::filter方法可以给列设置一个过滤器，可以很方便的根据这一列进行数据表格过滤操作，具体使用方法请参考列过滤器。"},{"h2":"","h3":"扩展列功能","h4":"","name":"扩展列功能-h3","content":"通过Grid\\Column::macro方法可以扩展列方法。  在 app/Admin/bootstrap.php 中添加以下代码  use Dcat\\Admin\\Grid; Grid\\Column::macro('myHeader', function ($p1, $p2 = null) { // MyHeader 需要实现 Illuminate\\Contracts\\Support\\Renderable 接口 // 当然这里也可以直接传字符串 return $this->addHeader(new MyHeader($this, $p1, $p2)); });  MyHeader 类  use Dcat\\Admin\\Grid\\Column; use Illuminate\\Contracts\\Support\\Renderable; class MyHeader implements Renderable { public function __construct(Column $column, $p1, $p2) { ... } public function render() { ... } }  使用  $grid->user->myHeader($p1, $p2); $grid->first_name->myHeader($p1);"}]},{"title":"组合表头","link":"model-grid-combination","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"通过 Grid::combine 方法可以很方便的把任意两个以上的字段组合成一级表头 示例 protected function grid() { return Grid::make(new Report(), function (Grid $grid) { // 第一个参数为一级表头字段名称，第二个字段为二级表头字段名称，二级表头字段最少设置两个 $grid->combine('avgCost', ['avgMonthCost', 'avgQuarterCost', 'avgYearCost']); // 启用RWD-Table-Patterns插件 $grid->combine('avgVist', ['avgMonthVist', 'avgQuarterVist', 'avgYearVist'])->responsive(); // 启用RWD-Table-Patterns插件并设置样式 $grid->combine('top', ['topCost', 'topVist', 'topIncr'])->responsive()->style('color:#1867c0'); $grid->content->limit(50)->responsive(); $grid->cost->sortable()->responsive(); $grid->avgMonthCost->responsive(); $grid->avgQuarterCost->responsive()->setHeaderAttributes(['style' => 'color:#5b69bc']); $grid->avgYearCost->responsive(); $grid->avgMonthVist->responsive(); $grid->avgQuarterVist->responsive(); $grid->avgYearVist->responsive(); $grid->incrs->hide(); $grid->avgVists->hide(); $grid->topCost->responsive(); $grid->topVist->responsive(); $grid->topIncr->responsive(); $grid->date->sortable()->responsive(); }); }"}]},{"title":"工具栏","link":"model-grid-custom-tools","nodes":[{"h2":"工具按钮","h3":"","h4":"","name":"工具按钮-h2","content":"在model-grid的头部默认有批量删除和刷新两个操作工具，如果有更多的操作需求，Grid 提供了自定义工具的功能,下面的示例添加一个性别分类选择的按钮组工具。  先定义工具类app/Admin/Extensions/Tools/UserGender.php：  <?php namespace App\\Admin\\Extensions\\Tools; use Dcat\\Admin\\Admin; use Dcat\\Admin\\Grid\\Tools\\AbstractTool; use Illuminate\\Support\\Facades\\Request; class UserGender extends AbstractTool { protected function script() { $url = Request::fullUrlWithQuery(['gender' => '_gender_']); return <<<JS $('input:radio.user-gender').change(function () { var url = \"$url\".replace('_gender_', $(this).val()); LA.reload(url); }); JS; } public function render() { Admin::script($this->script()); $options = [ 'all' => 'All', 'm' => 'Male', 'f' => 'Female', ]; return view('admin.tools.gender', compact('options')); } }   视图admin.tools.gender文件为resources/views/admin/tools/gender.blade.php:  <div class=\"btn-group\" data-toggle=\"buttons\"> @foreach($options as $option => $label) <label class=\"btn btn-default btn-sm {{ \\Request::get('gender', 'all') == $option ? 'active' : '' }}\"> <input type=\"radio\" class=\"user-gender\" value=\"{{ $option }}\">{{$label}} </label> @endforeach </div>  在Grid引入这个工具：  $grid->tools(new UserGender());  在model-grid定义中接收到gender参数后，做好数据查询就可以了：  if (in_array(Request::get('gender'), ['m', 'f'])) { $grid->model()->where('gender', Request::get('gender')); }  可以参考上面的方式来添加自己的工具。"},{"h2":"工具按钮","h3":"tools用法","h4":"","name":"tools用法-h3","content":"Grid::tools 方法允许传入 string，array, AbstractTool 和 闭包等类型参数，下面是演示。  // 传入字符串 $grid->tools('<a class=\"btn btn-sm btn-default\">工具按钮测试</a>'); // 传入数组 $grid->tools([ '<a class=\"btn btn-sm btn-default\">工具按钮测试</a>', new UserGender(), ]); // 传入闭包 $grid->tools(function (Grid\\Tools $tools) { $tools->append(new UserGender()); });"},{"h2":"批量操作","h3":"","h4":"","name":"批量操作-h2","content":"目前默认实现了批量删除操作的功能，如果要关掉批量删除操作：  $grid->tools(function ($tools) { $tools->batch(function ($batch) { $batch->disableDelete(); }); }); // 也可以这样 $grid->disableBatchDelete(); // 或 $grid->batchActions(function (Grid\\Tools\\BatchActions $batch) { $batch->disableDelete(); });  如果要添加自定义的批量操作，可以参考下面的例子。  下面是扩展一个对文章批量发布的功能：  先定义操作类app/Admin/Extensions/Tools/ReleasePost.php：  <?php namespace App\\Admin\\Extensions\\Tools; use Dcat\\Admin\\Grid\\BatchAction; class ReleasePost extends BatchAction { protected $action; public function __construct($title, $action = 1) { $this->title = $title; $this->action = $action; } public function script() { return <<<JS $('{$this->elementClass()}').on('click', function() { // 获取选中的id数组 var idArray = {$this->getSelectedKeysScript()} $.ajax({ method: 'post', url: '{$this->resource()}/release', data: { _token:LA.token, ids: idArray.join(), action: {$this->action} }, success: function () { LA.reload(); LA.success('操作成功'); } }); }); JS; } }  看代码的实现，通过click操作发送一个post请求，把选中的行数据id通过数组的形式传给后端接口，后端接口拿到id列表和要修改的状态来更新数据，然后前端刷新页面(pjax reload)，并弹出toastr提示操作成功。  在model-grid中加入这个批量操作功能：  $grid->batchActions([ new ReleasePost('发布文章', 1), new ReleasePost('文章下线', 0) ]); // 也可以这么写 $grid->batchActions(function ($batch) { $batch->add(new ReleasePost('发布文章', 1)); $batch->add(new ReleasePost('文章下线', 0)); }); // 或 $grid->tools(function ($tools) { $tools->batch(function ($batch) { $batch->add(new ReleasePost('发布文章', 1)); $batch->add(new ReleasePost('文章下线', 0)); }); });  这样批量操作下拉按钮下面就会添加两个操作项，最后一步就是添加一个接口来处理批量操作的请求了，接口代码如下：   class PostController extends Controller { ... public function release(Request $request) { foreach (Post::find($request->get('ids')) as $post) { $post->released = $request->get('action'); $post->save(); } } ... }  然后添加路由指向上面的接口：  $router->post('posts/release', 'PostController@release');  这样整个流程就完成了。"}]},{"title":"表格数据源","link":"model-grid-data","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"表格数据是通过 Dcat\\Admin\\Contracts\\Repository::get 接口获取的。 如果你的数据源是 MySQL，则可以直接使用 Dcat\\Admin\\Repositories\\EloquentRepository， EloquentRepository 已实现了对 Eloquent Model 的支持。 如果数据来自其他源，则只需重新实现 Dcat\\Admin\\Contracts\\Repository::get 接口即可。 Repository提供更简单更清晰数据操作接口，开发者可以通过实现不同的数据操作接口轻松支持多数据源，具体使用方法请参照数据仓库。 "},{"h2":"数据来自模型","h3":"","h4":"","name":"model","content":"当数据源支持Eloquent Model时，只需创建一个简单的Repository类继承Dcat\\Admin\\Repositories\\EloquentRepository即可  <?php namespace App\\Admin\\Repositories; use Dcat\\Admin\\Repositories\\EloquentRepository; use App\\Models\\Movie as MovieModel; class Movie extends EloquentRepository { // 这里定义你的模型类名 protected $eloquentClass = MovieModel::class; // 通过这个方法可以指定查询的字段，默认\"*\" public function getGridColumns() { return [$this->getKeyName(), 'name', 'title', 'created_at']; } }"},{"h2":"数据来自模型","h3":"直接使用模型","h4":"","name":"直接使用模型-h3","content":"如果你还觉得创建 Repository 类麻烦，也可以直接把 Eloquent Model 的示例传递到 Grid 中，底层会自动把 Eloquent Model 转化为 EloquentRepository 实例   use App\\Models\\Movie as MovieModel; $grid = new Grid(new MovieModel()); ..."},{"h2":"数据来自模型","h3":"修改来源数据","h4":"","name":"修改来源数据-h3","content":"1、使用 Grid\\Model  use App\\Admin\\Repositories\\Movie; $grid = new Grid(new Movie()); // 添加默认查询条件 $grid->model()->where('id', '>', 100); // 设置初始排序条件 $grid->model()->orderBy('id', 'desc'); ...   其它查询方法可以参考eloquent的查询方法。  2、使用 Model Query  use App\\Models\\Movie as MovieModel; $grid = new Grid(MovieModel::where('id', '>', 100)); ..."},{"h2":"数据来自模型","h3":"关联数据","h4":"","name":"关联数据-h3","content":"有以下三种方式让你的表格支持关联数据  1、使用Repository  use App\\Admin\\Repositories\\Movie; // 相当于 MovieModel::with('categories') $grid = new Grid(new Movie(['categories'])); $grid->categories; ...  2、使用 Grid\\Model  use App\\Admin\\Repositories\\Movie; $grid = new Grid(new Movie()); $grid->model()->with('categories'); $grid->categories; ...  3、使用 Model Query  use App\\Models\\Movie as MovieModel; $grid = new Grid(MovieModel::with('categories')); $grid->categories; ..."},{"h2":"数据来自外部API","h3":"示例","h4":"","name":"example","content":"如果数据是来自外部的API，只需要覆写Repository中的get方法既可, 下面的例子用豆瓣电影的API获取并展示数据：   通过$model->getFilter()->input()方法可以获取过滤器定义的字段值，请尽量不要通过request()方法去获取过滤器筛选参数值，因为当页面中有多个表格时可能无法获取到值。关于过滤器定义请参考查询过滤。   <?php namespace App\\Admin\\Repositories; use Dcat\\Admin\\Grid; use Dcat\\Admin\\Repositories\\Repository; use Illuminate\\Pagination\\LengthAwarePaginator; class ComingSoon extends Repository { protected $api = 'https://api.douban.com/v2/movie/coming_soon'; /** * 定义主键字段名称 * * @return string */ public function getPrimaryKeyColumn() { return '_id'; } /** * 查询表格数据 * * @param Grid\\Model $model * @return LengthAwarePaginator */ public function get(Grid\\Model $model) { // 获取当前页数 $currentPage = $model->getCurrentPage(); // 获取每页显示行数 $perPage = $model->getPerPage(); // 获取排序字段 list($orderColumn, $orderType) = $model->getSort(); // 获取\"scope\"筛选值 $city = $model->getFilter()->input(Grid\\Filter\\Scope::QUERY_NAME, '广州'); // 如果设置了其他过滤器字段，也可以通过“input”方法获取值，如： $title = $model->getFilter()->input('title'); if ($title !== null) { // 执行你的筛选逻辑 } $start = ($currentPage - 1) * $perPage; $client = new \\GuzzleHttp\\Client(); $response = $client->get(\"{$this->api}?city=$city&start=$start&count=$perPage\"); $data = json_decode((string)$response->getBody(), true); // 实例化分页类 $paginator = new LengthAwarePaginator( $data['subjects'] ?? [], $data['total'] ?? 0, $perPage, // 传入每页显示行数 $currentPage // 传入当前页码 ); // 设置当前页面路径 $paginator->setPath(\\url()->current()); return $paginator; } }"},{"h2":"数据来自外部API","h3":"$grid->model() 内置方法","h4":"getCurrentPage","name":"getCurrentPage","content":"获取当前页码   返回值： int|null 如果不允许分页返回null $page = $model->getCurrentPage(); "},{"h2":"数据来自外部API","h3":"$grid->model() 内置方法","h4":"getPerPage","name":"getPerPage","content":"获取每页显示行数   返回值： int|null 如果不允许分页返回null $limit = $model->getPerPage(); "},{"h2":"数据来自外部API","h3":"$grid->model() 内置方法","h4":"getSort","name":"getSort","content":"获取排序字段   返回值： array [$orderColumn, 'desc'|'asc'] || [null, null]   // $orderColumn 字段名称，如没有进行排序则为 null // $orderType 正序或倒序： \"desc\"、\"asc\"，如没有进行排序则为 null list($orderColumn, $orderType) = $model->getSort();"},{"h2":"数据来自外部API","h3":"$grid->model() 内置方法","h4":"getFilter","name":"getFilter","content":"获取过滤器对象   返回值 Dcat\\Admin\\Grid\\Filter   // 获取\"scope\"筛选值 $city = $model->getFilter()->input(Grid\\Filter\\Scope::QUERY_NAME, '广州'); // 如果设置了其他过滤器字段，也可以通过“input”方法获取值，如： $title = $model->getFilter()->input('title'); if ($title !== null) { // 执行你的筛选逻辑 }"},{"h2":"数据来自复杂SQL查询","h3":"","h4":"","name":"sql","content":"如果来源数据需要执行比较复杂的SQL语句获取，那么有两个办法, 第一个办法就是上面的方法，覆盖掉Repository的get方法实现  第二个方式是在数据库中建立视图和model绑定（未测试过，理论上可行）"}]},{"title":"数据表格事件","link":"model-grid-events","nodes":[{"h2":"","h3":"初始化","h4":"","name":"初始化-h3","content":"通过 Grid::resolving 方法可以监听表格初始化事件。  开发者可以在这两个事件中改变 Grid 的一些设置或行为，比如需要禁用掉某些操作，可以在 app/Admin/bootstrap.php 加入下面的代码：  use Dcat\\Admin\\Grid; Grid::resolving(function (Grid $grid) { $grid->disableActions(); $grid->disablePagination(); $grid->disableCreateButton(); $grid->disableFilter(); $grid->disableRowSelector(); $grid->disableTools(); $grid->disableExport(); }); // 只需要监听一次 Grid::resolving(function (Grid $grid) { ... }, true);  这样就不用在每一个控制器的代码中来设置了。  如果全局设置后，要在其中某一个表格中开启设置，比如开启显示操作列，在对应的实例上调用 $grid->disableActions(false); 就可以了"},{"h2":"","h3":"构建","h4":"","name":"构建-h3","content":"通过 Grid::composing 方法可以监听表格被调用事件。  Grid::composing(function (Grid $grid) { ... }); // 只需要监听一次 Grid::composing(function (Grid $grid) { ... }, true);"},{"h2":"","h3":"获取数据之前","h4":"","name":"获取数据之前-h3","content":"通过 Grid::fetching 方法可以监听表格获取数据之前事件，此事件在 composing 事件之后触发。   $grid = new Grid(...); $grid->fetching(function () { ... }); // 可以在 composing 事件中使用 Grid::composing(function (Grid $grid) { $grid->fetching(function (Grid $grid) { ... }); });"},{"h2":"","h3":"获取数据之后","h4":"","name":"获取数据之后-h3","content":"通过 Grid::rows 方法可以监听表格获取数据之后事件。  use Dcat\\Admin\\Grid\\Row; use Illuminate\\Support\\Collection; $grid->rows(function (Collection $rows) { /** * 获取第一行数据 * * @var Row $firstRow */ $firstRow = $rows->first(); if ($firstRow) { // 获取第一行的 id $id = $firstRow->id; // 转化为数组 $row = $firstRow->toArray(); } });"}]},{"title":"数据导出","link":"model-grid-export","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"系统默认使用Easy Excel作为导出工具，支持导出 csv、 xlsx 和 ods 等格式文件。 使用前必须先安装Easy Excel： composer require dcat/easy-excel 默认不开启导出功能。 "},{"h2":"扩展导出功能","h3":"","h4":"","name":"disable-export-extend","content":"如果系统内置的导出功能不了自己的需求，可以按照下面的步骤来自定义导出功能  本示例用Laravel-Excel作为excel操作库，当然也可以使用任何其他excel库  首先安装好它：  composer require maatwebsite/excel:~2.1.0 php artisan vendor:publish --provider=\"Maatwebsite\\Excel\\ExcelServiceProvider\"  然后新建自定义导出类，比如app/Admin/Extensions/ExcelExpoter.php:  <?php namespace App\\Admin\\Extensions; use Dcat\\Admin\\Grid\\Exporters\\AbstractExporter; use Maatwebsite\\Excel\\Facades\\Excel; class ExcelExpoter extends AbstractExporter { public function export() { Excel::create('Filename', function($excel) { $excel->sheet('Sheetname', function($sheet) { // 最多导出10W条数据 // 必须设置maxSize，当否则选择导出所有选项时只能导出默认的20条数据。 $maxSize = 10000; // 这段逻辑是从表格数据中取出需要导出的字段 $rows = collect($this->buildData(1, $maxSize))->map(function ($item) { return array_only($item, ['id', 'title', 'content', 'rate', 'keywords']); }); $sheet->rows($rows); }); })->export('xls'); } }  然后在model-grid中使用这个导出类：   use App\\Admin\\Extensions\\ExcelExpoter; $grid->export(new ExcelExpoter());  有关更多Laravel-Excel的使用方法，参考laravel-excel/docs"}]},{"title":"自定义导出","link":"model-grid-exporter","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"dcat-admin的数据表格默认支持导出csv文件， <?php namespace App\\Admin\\Extensions; use Dcat\\Admin\\Grid\\Exporters\\AbstractExporter; class CustomExporter extends AbstractExporter { public function export() { $filename = $this->getTable().'.csv'; $data = $this->getData(); $output = ''; $headers = [ 'Content-Encoding' => 'UTF-8', 'Content-Type' => 'text/csv;charset=UTF-8', 'Content-Disposition' => \"attachment; filename=\\\"$filename\\\"\", ]; response(rtrim($output, \"\\n\"), 200, $headers)->send(); exit; } }"}]},{"title":"查询过滤","link":"model-grid-filters","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"model-grid提供了一系列的方法实现表格数据的查询过滤： // 禁用 $grid->disableFilter(); // 显示 $grid->showFilter(); // 禁用过滤器按钮 $grid->disableFilterButton(); // 显示过滤器按钮 $grid->showFilterButton(); $grid->filter(function($filter){ // 展开过滤器 $filter->expand(); // 在这里添加字段过滤器 $filter->equal('id', '产品序列号'); $filter->like('name', 'name'); ... });"},{"h2":"过滤器布局","h3":"","h4":"","name":"过滤器布局-h2","content":"默认布局方式为rightSide"},{"h2":"过滤器布局","h3":"rightSide","h4":"","name":"rightSide-h3","content":"use Dcat\\Admin\\Grid; $grid->filter(function (Grid\\Filter $filter) { // 更改为 rightSide 布局 $grid->rightSide(); ... });  效果"},{"h2":"过滤器布局","h3":"panel","h4":"","name":"panel-h3","content":"use Dcat\\Admin\\Grid; $grid->filter(function (Grid\\Filter $filter) { // 更改为 panel 布局 $grid->panel(); ... });  效果"},{"h2":"查询类型","h3":"","h4":"","name":"type","content":"目前支持的过滤类型有下面这些:"},{"h2":"查询类型","h3":"equal","h4":"","name":"equal","content":"sql: ... WHEREcolumn= \"$input\"：  $filter->equal('column', $label);"},{"h2":"查询类型","h3":"notEqual","h4":"","name":"nequal","content":"sql: ... WHEREcolumn!= \"$input\"：  $filter->notEqual('column', $label);"},{"h2":"查询类型","h3":"like","h4":"","name":"like","content":"sql: ... WHEREcolumnLIKE \"%$input%\"：  $filter->like('column', $label);"},{"h2":"查询类型","h3":"ilike","h4":"","name":"ilike-h3","content":"sql: ... WHEREcolumnILIKE \"%$input%\"：  $filter->ilike('column', $label);"},{"h2":"查询类型","h3":"startWith","h4":"","name":"startwith","content":"sql: ... WHEREcolumnLIKE \"$input%\"：  $filter->startWith('column', $label); // 如果需要使用“ilike” $filter->startWith('column', $label)->ilike();"},{"h2":"查询类型","h3":"endWith","h4":"","name":"endwith","content":"sql: ... WHEREcolumnLIKE \"%$input\"：  $filter->endWith('column', $label); // 如果需要使用“ilike” $filter->endWith('column', $label)->ilike();"},{"h2":"查询类型","h3":"gt","h4":"","name":"gt","content":"sql: ... WHEREcolumn> \"$input\"：  $filter->gt('column', $label);"},{"h2":"查询类型","h3":"lt","h4":"","name":"lt","content":"sql: ... WHEREcolumn< \"$input\"：  $filter->lt('column', $label);"},{"h2":"查询类型","h3":"ngt","h4":"","name":"ngt","content":"sql: ... WHEREcolumn<= \"$input\"：  $filter->ngt('column', $label);"},{"h2":"查询类型","h3":"nlt","h4":"","name":"nlt","content":"sql: ... WHEREcolumn>= \"$input\"：  $filter->nlt('column', $label);"},{"h2":"查询类型","h3":"between","h4":"","name":"between","content":"sql: ... WHEREcolumnBETWEEN \"$start\" AND \"$end\"：  $filter->between('column', $label); // 设置datetime类型 $filter->between('column', $label)->datetime(); // 设置time类型 $filter->between('column', $label)->time();"},{"h2":"查询类型","h3":"in","h4":"","name":"in","content":"sql: ... WHEREcolumnin (...$inputs)：  $filter->in('column', $label)->multipleSelect(['key' => 'value']);"},{"h2":"查询类型","h3":"notIn","h4":"","name":"notIn","content":"sql: ... WHEREcolumnnot in (...$inputs)：  $filter->notIn('column', $label)->multipleSelect(['key' => 'value']);"},{"h2":"查询类型","h3":"date","h4":"","name":"date","content":"sql: ... WHERE DATE(column) = \"$input\"：  $filter->date('column', $label);"},{"h2":"查询类型","h3":"day","h4":"","name":"day","content":"sql: ... WHERE DAY(column) = \"$input\"：  $filter->day('column', $label);"},{"h2":"查询类型","h3":"month","h4":"","name":"month","content":"sql: ... WHERE MONTH(column) = \"$input\"：  $filter->month('column', $label);"},{"h2":"查询类型","h3":"year","h4":"","name":"year","content":"sql: ... WHERE YEAR(column) = \"$input\"：  $filter->year('column', $label);"},{"h2":"查询类型","h3":"复杂查询where","h4":"","name":"where","content":"可以用where来构建比较复杂的查询过滤  sql: ... WHEREtitleLIKE \"%$input\" ORcontentLIKE \"%$input\"：  $filter->where('search', function ($query) { $query->where('title', 'like', \"%{$this->input}%\") ->orWhere('content', 'like', \"%{$this->input}%\"); });  sql: ... WHERErate>= 6 ANDcreated_at= {$input}:  $filter->where(function ($query) { $query->whereRaw(\"`rate` >= 6 AND `created_at` = {$this->input}\"); }, 'Text');  关系查询，查询对应关系profile的字段：  $filter->where(function ($query) { $query->whereHas('profile', function ($query) { $query->where('address', 'like', \"%{$this->input}%\")->orWhere('email', 'like', \"%{$this->input}%\"); }); }, '地址或手机号');"},{"h2":"查询类型","h3":"过滤器组group","h4":"","name":"group","content":"有时候对同一个字段要设置多种筛选方式，可以通过下面的方式实现  $filter->group('rate', function ($group) { $group->gt('大于'); $group->lt('小于'); $group->nlt('不小于'); $group->ngt('不大于'); $group->equal('等于'); });  有下面的几个方法可以调用  // 等于 $group->equal(); // 不等于 $group->notEqual(); // 大于 $group->gt(); // 小于 $group->lt(); // 大于等于 $group->nlt(); // 小于等于 $group->ngt(); // 匹配 $group->match(); // 复杂条件 $group->where(); // like查询 $group->like(); // like查询 $group->contains(); // ilike查询 $group->ilike(); // 以输入的内容开头 $group->startWith(); // 以输入的内容结尾 $group->endWith();"},{"h2":"查询类型","h3":"范围查询scope","h4":"","name":"scope","content":"可以把你最常用的查询定义为一个查询范围，它将会出现在筛选按钮的下拉菜单中，下面是几个例子：  $filter->scope('male', '男性')->where('gender', 'm'); // 多条件查询 $filter->scope('new', '最近修改') ->whereDate('created_at', date('Y-m-d')) ->orWhere('updated_at', date('Y-m-d')); // 关联关系查询 $filter->scope('address')->whereHas('profile', function ($query) { $query->whereNotNull('address'); }); $filter->scope('trashed', '被软删除的数据')->onlyTrashed();  scope方法第一个参数为查询的key, 会出现的url参数中，第二个参数是下拉菜单项的label, 如果不填，第一个参数会作为label显示  scope方法可以链式调用任何eloquent查询条件，效果参考Demo"},{"h2":"表单类型","h3":"text","h4":"","name":"text","content":"表单类型默认是text input，可以设置placeholder：  $filter->equal('column')->placeholder('请输入。。。');  也可以通过下面的一些方法来限制用户输入格式：  $filter->equal('column')->url(); $filter->equal('column')->email(); $filter->equal('column')->integer(); $filter->equal('column')->ip(); $filter->equal('column')->mac(); $filter->equal('column')->mobile(); // $options 参考 https://github.com/RobinHerbots/Inputmask/blob/4.x/README_numeric.md $filter->equal('column')->decimal($options = []); // $options 参考 https://github.com/RobinHerbots/Inputmask/blob/4.x/README_numeric.md $filter->equal('column')->currency($options = []); // $options 参考 https://github.com/RobinHerbots/Inputmask/blob/4.x/README_numeric.md $filter->equal('column')->percentage($options = []); // $options 参考 https://github.com/RobinHerbots/Inputmask, $icon为input前面的图标 $filter->equal('column')->inputmask($options = [], $icon = 'pencil');"},{"h2":"表单类型","h3":"selectResource","h4":"","name":"selectResource","content":"选择数据源，选择弹窗里面的表格数据。  // 单选 $filter->equal('user_id') ->selectResource('pages/users') ->placeholder('请选择。。。') ->options(function ($v) { // options方法用于显示已选中的值 if (!$v) return $v; $userModel = config('admin.database.users_model'); return $userModel::findOrFail($v)->pluck('name', 'id'); }); // 多选 $filter->in('user_id') ->selectResource('pages/users') ->multiple(3) // 最多选择3个选项，不传则不限制 ->options(function ($v) { // options方法用于显示已选中的值 if (!$v) return $v; $userModel = config('admin.database.users_model'); return $userModel::findOrFail($v)->pluck('name', 'id'); });  pages/users页面实现：  /** * Index interface. * * @return Content */ public function index(Content $content) { if (request('_mini')) { return $content->body($this->miniGrid()); } ... } protected function miniGrid() { $grid = new MiniGrid(new Administrator()); // 指定行选择器选中时显示的值的字段名称 // 指定行选择器选中时显示的值的字段名称 // 指定行选择器选中时显示的值的字段名称 // 如果表格数据中带有 “name”、“title”或“username”字段，则可以不用设置 $grid->setRowSelectorOptions(['label' => 'username']); $grid->id->sortable(); $grid->username; $grid->name; $grid->filter(function (Grid\\Filter $filter) { $filter->equal('id'); $filter->like('username'); $filter->like('name'); }); return $grid; } "},{"h2":"表单类型","h3":"select","h4":"","name":"select","content":"$filter->equal('column')->select(['key' => 'value'...]); // 或者从api获取数据，api的格式参考model-form的select组件 $filter->equal('column')->select('api/users');"},{"h2":"表单类型","h3":"multipleSelect","h4":"","name":"multipleSelect","content":"一般用来配合in和notIn两个需要查询数组的查询类型使用，也可以在where类型的查询中使用：  $filter->in('column')->multipleSelect(['key' => 'value'...]); // 或者从api获取数据，api的格式参考model-form的multipleSelect组件 $filter->in('column')->multipleSelect('api/users');"},{"h2":"表单类型","h3":"datetime","h4":"","name":"datetime","content":"通过日期时间组件来查询，$options的参数和值参考bootstrap-datetimepicker  $filter->equal('column')->datetime($options); // `date()` 相当于 `datetime(['format' => 'YYYY-MM-DD'])` $filter->equal('column')->date(); // `time()` 相当于 `datetime(['format' => 'HH:mm:ss'])` $filter->equal('column')->time(); // `day()` 相当于 `datetime(['format' => 'DD'])` $filter->equal('column')->day(); // `month()` 相当于 `datetime(['format' => 'MM'])` $filter->equal('column')->month(); // `year()` 相当于 `datetime(['format' => 'YYYY'])` $filter->equal('column')->year(); "},{"h2":"常用方法","h3":"设置过滤器宽度","h4":"","name":"width","content":"// 设置为“1-12”之间的值，默认值是“3” $filter->equal('column')->width(3); // 也可以写死宽度 $filter->equal('column')->width('250px');"},{"h2":"常用方法","h3":"设置默认值","h4":"","name":"default","content":"$filter->equal('column')->default('text'); $filter->equal('column')->select([0 => 'PHP', 1 => 'Java'])->default(1);"},{"h2":"常用方法","h3":"展开过滤器","h4":"","name":"expand","content":"$filter->expand(); $filter->equal('column'); ..."},{"h2":"常用方法","h3":"不显示过滤器input输入框的边框","h4":"","name":"withoutInputBorder","content":"$filter->withoutInputBorder(); $filter->equal('column'); ..."},{"h2":"常用方法","h3":"设置过滤器容器样式","h4":"","name":"style","content":"$filter->style('padding:0'); $filter->equal('column'); ..."},{"h2":"常用方法","h3":"设置过滤器容器padding","h4":"","name":"padding","content":"$filter->padding('10px', '10px', '10px', '10px'); $filter->equal('column'); ..."},{"h2":"自定义过滤器","h3":"","h4":"","name":"extend","content":"下面通过between的实现来讲解下怎么自定义过滤器。  首先新建一个过滤器类继承Dcat\\Admin\\Grid\\Filter\\AbstractFilter：  <?php namespace Dcat\\Admin\\Grid\\Filter; use Dcat\\Admin\\Admin; use Dcat\\Admin\\Grid\\Filter\\Presenter\\DateTime; use Illuminate\\Support\\Arr; class Between extends AbstractFilter { // 自定义你的过滤器显示模板 protected $view = 'admin::filter.between'; // 这个方法用于生成过滤器字段的唯一id // 通过这个唯一id则可以用js代码对其进行操作 public function formatId($column) { $id = str_replace('.', '_', $column); $name = $this->parent->getGrid()->getName(); return ['start' => \"{$name}{$id}_start\", 'end' => \"{$name}{$id}_end\"]; } // form表单name属性格式化 protected function formatName($column) { $columns = explode('.', $column); if (count($columns) == 1) { $name = $columns[0]; } else { $name = array_shift($columns); foreach ($columns as $column) { $name .= \"[$column]\"; } } return ['start' => \"{$name}[start]\", 'end' => \"{$name}[end]\"]; } // 创建条件 // 这里构建的条件支持`Laravel query builder`即可。 public function condition($inputs) { if (!Arr::has($inputs, $this->column)) { return; } $this->value = Arr::get($inputs, $this->column); $value = array_filter($this->value, function ($val) { return $val !== ''; }); if (empty($value)) { return; } if (!isset($value['start']) && isset($value['end'])) { // 这里返回的数组相当于 // $query->where($this->column, '<=', $value['end']); return $this->buildCondition($this->column, '<=', $value['end']); } if (!isset($value['end']) && isset($value['start'])) { // 这里返回的数组相当于 // $query->where($this->column, '>=', $value['end']); return $this->buildCondition($this->column, '>=', $value['start']); } $this->query = 'whereBetween'; // 这里返回的数组相当于 // $query->whereBetween($this->column, $value['end']); return $this->buildCondition($this->column, $this->value); } // 自定义过滤器表单显示方式 public function datetime($options = []) { $this->view = 'admin::filter.betweenDatetime'; DateTime::collectAssets(); $this->setupDatetime($options); return $this; } protected function setupDatetime($options = []) { $options['format'] = Arr::get($options, 'format', 'YYYY-MM-DD HH:mm:ss'); $options['locale'] = Arr::get($options, 'locale', config('app.locale')); $startOptions = json_encode($options); $endOptions = json_encode($options + ['useCurrent' => false]); // 通过上面格式化后的id对表单进行你想要的操作 $script = <<<JS $('#{$this->id['start']}').datetimepicker($startOptions); $('#{$this->id['end']}').datetimepicker($endOptions); $(\"#{$this->id['start']}\").on(\"dp.change\", function (e) { $('#{$this->id['end']}').data(\"DateTimePicker\").minDate(e.date); }); $(\"#{$this->id['end']}\").on(\"dp.change\", function (e) { $('#{$this->id['start']}').data(\"DateTimePicker\").maxDate(e.date); }); JS; Admin::script($script); } }  admin::filter.between模板内容如下：  <div class=\"filter-input col-sm-{{ $width }} \" style=\"{!! $style !!}\"> <div class=\"form-group\" > <div class=\"input-group input-group-sm\"> <span class=\"input-group-addon\"><b>{!! $label !!}</b></span> <input type=\"text\" class=\"form-control\" placeholder=\"{{$label}}\" name=\"{{$name['start']}}\" value=\"{{ request($name['start'], \\Illuminate\\Support\\Arr::get($value, 'start')) }}\"> <span class=\"input-group-addon\" style=\"border-left: 0; border-right: 0;\">To</span> <input type=\"text\" class=\"form-control\" placeholder=\"{{$label}}\" name=\"{{$name['end']}}\" value=\"{{ request($name['end'], \\Illuminate\\Support\\Arr::get($value, 'end')) }}\"> </div> </div> </div>  admin::filter.betweenDatetime模板内容如下：  <div class=\"filter-input col-sm-{{ $width }}\" style=\"{!! $style !!}\"> <div class=\"form-group\"> <div class=\"input-group input-group-sm\"> <span class=\"input-group-addon\"><b>{{$label}}</b> &nbsp;<i class=\"fa fa-calendar\"></i></span> <input type=\"text\" class=\"form-control\" id=\"{{$id['start']}}\" placeholder=\"{{$label}}\" name=\"{{$name['start']}}\" value=\"{{ request($name['start'], \\Illuminate\\Support\\Arr::get($value, 'start')) }}\"> <span class=\"input-group-addon\" style=\"border-left: 0; border-right: 0;\">To</span> <input type=\"text\" class=\"form-control\" id=\"{{$id['end']}}\" placeholder=\"{{$label}}\" name=\"{{$name['end']}}\" value=\"{{ request($name['end'], \\Illuminate\\Support\\Arr::get($value, 'end')) }}\"> </div> </div> </div>  现在只要调用extend方法可以使用了，打开app/Admin/bootstrap.php，加入以下代码：  Filter::extend('customBetween', Filter\\Between::class);  使用：   扩展过滤器方法后IDE默认是不会自动补全的，这时候可以通过php artisan admin::ide-helper生成IDE提示文件，具体请参考IDE自动补全。   $filter->customBetween('created_at')->datetime();"}]},{"title":"快捷创建","link":"model-grid-quick-create","nodes":[]},{"title":"表格快捷搜索","link":"model-grid-quick-search","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"快捷搜索是除了filter之外的另一个表格数据搜索方式，用来快速过滤你想要的数据，开启方式如下： $grid->quickSearch(); 这样表头会出现一个搜索框: 通过给quickSearch方法传入不同的参数，来设置不同的搜索方式，有下面几种使用方法"},{"h2":"Like搜索","h3":"","h4":"","name":"Like搜索-h2","content":"第一种方式，通过设置字段名称来进行简单的like查询  $grid->quickSearch('title'); // 提交后模型会执行下面的查询 $model->where('title', 'like', \"%{$input}%\");  或者对多个字段做like查询:  $grid->quickSearch('title', 'desc', 'content'); // 或 $grid->quickSearch(['title', 'desc', 'content']); // 提交后模型会执行下面的查询 $model->where('title', 'like', \"%{$input}%\") ->orWhere('desc', 'like', \"%{$input}%\") ->orWhere('content', 'like', \"%{$input}%\");"},{"h2":"自定义搜索","h3":"","h4":"","name":"自定义搜索-h2","content":"第二种方式可以让你更灵活的控制搜索条件  $grid->quickSearch(function ($model, $query) { $model->where('title', $query)->orWhere('desc', 'like', \"%{$query}%\"); });  其中闭包的参数$query为你填入搜索框中的内容，提交之后进行闭包中的查询。"},{"h2":"快捷语法搜索","h3":"","h4":"","name":"快捷语法搜索-h2","content":"第三种方式参考了Github的搜索语法，来进行快捷搜索，调用方式：  // 不传参数 $grid->quickSearch();  填入搜索框的内容按照以下的语法，在提交之后会进行相应的查询 :"},{"h2":"快捷语法搜索","h3":"比较查询","h4":"","name":"比较查询-h3","content":"title:foo 、title:!foo  $model->where('title', 'foo'); $model->where('title', '!=', 'foo');  rate:>10、rate:<10、rate:>=10、rate:<=10  $model->where('rate', '>', 10); $model->where('rate', '<', 10); $model->where('rate', '>=', 10); $model->where('rate', '<=', 10);"},{"h2":"快捷语法搜索","h3":"In、NotIn查询","h4":"","name":"In、NotIn查询-h3","content":"status:(1,2,3,4)、status:!(1,2,3,4)  $model->whereIn('status', [1,2,3,4]); $model->whereNotIn('status', [1,2,3,4]);"},{"h2":"快捷语法搜索","h3":"Between查询","h4":"","name":"Between查询-h3","content":"score:[1,10]  $model->whereBetween('score', [1, 10]);"},{"h2":"快捷语法搜索","h3":"时间日期函数查询","h4":"","name":"时间日期函数查询-h3","content":"created_at:date,2019-06-08  $model->whereDate('created_at', '2019-06-08');  created_at:time,09:57:45  $model->whereTime('created_at', '09:57:45');  created_at:day,08  $model->whereDay('created_at', '08');  created_at:month,06  $model->whereMonth('created_at', '06');  created_at:year,2019  $model->whereYear('created_at', '2019');"},{"h2":"快捷语法搜索","h3":"Like查询","h4":"","name":"Like查询-h3","content":"content:%Laudantium%、content:Laud%  $model->where('content', 'like', '%Laudantium%'); $model->where('content', 'like', 'Laud%');"},{"h2":"快捷语法搜索","h3":"正则查询","h4":"","name":"正则查询-h3","content":"username:/song/   这里请使用MYSQL正则语法   $model->where('username', 'REGEXP', 'song');"},{"h2":"快捷语法搜索","h3":"多条件组合搜索","h4":"","name":"多条件组合搜索-h3","content":"用空格隔开多个搜索语句就可以实现多个字段的AND查询，比如username:%song% status:(1,2,3), 提交之后会运行下面的搜索  $model->where('username', 'like', '%song%')->whereIn('status', [1, 2, 3]);  如果某一个条件是OR查询, 只需要在语句单元前增加一个|符号即可： username:%song% |status:(1,2,3)  $model->where('username', 'like', '%song%')->orWhereIn('status', [1, 2, 3]);   如果填入的查询文字中包含空格，需要放在双引号里面：updated_at:\"2019-06-08 09:57:45\" "},{"h2":"快捷语法搜索","h3":"Label作为查询字段名称","h4":"","name":"Label作为查询字段名称-h3","content":"不方便得到字段名的情况下，可以直接使用label名称作为查询字段   // 比如设置了`user_status`的表头列名为`用户状态` $grid->column('user_status', '用户状态');  那么可以填入用户状态:(1,2,3)来执行下面的查询  $model->whereIn('user_status', [1, 2, 3]);"}]},{"title":"表格字段翻译","link":"model-grid-trans","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"数据表格中所有使用到字段的地方都会自动读取语言包中的翻译。 语言包的详细使用方法请参考多语言。 "},{"h2":"","h3":"语言包名称","h4":"","name":"语言包名称-h3","content":"语言包名称需要与控制器名相对应，假如控制器名UserProfileController，则对应的语言包为resources/lang/{当前语言}/user-profile.php（需要转化为小写中划线风格）。"},{"h2":"","h3":"示例","h4":"","name":"示例-h3","content":"现在假设语言包resources/lang/zh-CN/user-profile.php内容如下：  return [ 'fields' => [ 'name' => '名称', 'age' => '年龄', 'class' => '班级', ], ];  控制器UserProfileController中设置的Grid字段会自动读取以上翻译：  // 不设置labael会自动读取语言包翻译 $grid->id(); $grid->name; $grid->age; $grid->class; $grid->filter(function ($filter) { $filter->gt('age'); }); // 上面代码等同于 $grid->name('名称'); $grid->age('年龄'); // 也可这样使用 $grid->id(admin_trans_field('id')); $grid->name(admin_trans_field('name')); $grid->age(admin_trans_field('age')); "},{"h2":"","h3":"公共翻译","h4":"","name":"公共翻译-h3","content":"当admin_trans_field函数找不到当前控制器中对指定字段的翻译时，会去global.php中查找。如果某些字段是很多数据表中都有的，可以把这些翻译写在resources/lang/{当前语言}/global.php文件中。  return [ // 常用的字段放在 global.php 中可以所有控制器共用。 'fields' => [ 'id' => 'ID', 'created_at' => '创建时间', 'updated_at' => '更新时间', ], ];"}]},{"title":"树状表格","link":"model-grid-tree","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"树状表格支持分页和点击加载功能，特别适合用来展示数据量较大的多层级结构数据。"},{"h2":"","h3":"表结构和模型","h4":"","name":"表结构和模型-h3","content":"要使用树状表格，要遵守约定的表结构：   此表结构和模型可完全兼容 模型树 。   CREATE TABLE `demo_categories` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `parent_id` int(11) NOT NULL DEFAULT '0', `order` int(11) NOT NULL DEFAULT '0', // order 字段不是必须的，不设置也可以 `title` varchar(50) COLLATE utf8_unicode_ci NOT NULL, `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci  上面的表格结构里面有三个必要的字段parent_id、title,其它字段没有要求。  对应的模型为app/Models/Category.php:   为了便于阅读，这里不再展示 Repository 代码。   <?php namespace App\\Models\\Demo; use Dcat\\Admin\\Traits\\ModelTree; use Illuminate\\Database\\Eloquent\\Model; class Category extends Model { use ModelTree; protected $table = 'demo_categories'; }  表结构中的三个字段parent_id、order、title的字段名也是可以修改的：  <?php namespace App\\Models\\Demo; use Dcat\\Admin\\Traits\\ModelTree; use Illuminate\\Database\\Eloquent\\Model; class Category extends Model { use ModelTree; protected $table = 'demo_categories'; protected $titleColumn = 'name'; protected $orderColumn = 'sort'; protected $parentColumn = 'pid'; }  如果你的数据表不需要 order 字段排序，则在模型中添加如下代码即可  <?php namespace App\\Models\\Demo; use Dcat\\Admin\\Traits\\ModelTree; use Illuminate\\Database\\Eloquent\\Model; class Category extends Model { use ModelTree; protected $table = 'demo_categories'; // 返回空值即可禁用 order 字段 public function getOrderColumn() { return null; } }"},{"h2":"","h3":"使用","h4":"","name":"使用-h3","content":"通过调用 Grid\\Column::tree 方法即可开启树状表格功能，开启之后默认只查询最顶级节点的数据，子节点数据需要点击加载  <?php namespace App\\Admin\\Controllers\\Demo; use App\\Models\\Category; use Dcat\\Admin\\Grid; use Dcat\\Admin\\Controllers\\AdminController; class CategoryController extends AdminController { protected function grid() { return Grid::make(new Category(), function (Grid $grid) { $grid->id('ID')->bold()->sortable(); $grid->title->tree(); // 开启树状表格功能 $grid->order; $grid->created_at; $grid->updated_at->sortable(); $grid->filter(function (Grid\\Filter $filter) { $filter->like('slug'); $filter->like('name'); $filter->like('http_path'); }); }); } }  上面的代码执行的 sql 如下（默认只查询 parent = 0 的数据）：  select count(*) as aggregate from `demo_categories` where `parent_id` = 0 select * from `demo_categories` where `parent_id` = 0 order by `order` asc, `id` asc limit 20 offset 0  Grid\\Column::tree 方法参数   bool $showAll false 是否一次性展示下一层级的所有节点，默认分页展示 bool $sortable true 是否开启排序功能   // 禁用分页功能，一次性加载所有下一层级节点 $grid->title->tree(true); // 不需要 order 字段排序，第二个参数传 false 即可 $grid->title->tree(false, false);"},{"h2":"","h3":"orderable排序","h4":"","name":"orderable排序-h3","content":"orderable 排序功能依赖 spatie/eloquent-sortable 组件，需要修改模型：  use Spatie\\EloquentSortable\\Sortable; class Category extends Model implements Sortable { use ModelTree; // 设置排序字段，默认order protected $orderColumn = 'sort'; }  下面是使用示例  class CategoryController extends AdminController { protected function grid() { return Grid::make(new Category(), function (Grid $grid) { $grid->id('ID')->bold()->sortable(); $grid->title->tree(); // 开启树状表格功能 $grid->order->orderable(); // 开启排序功能 ...; }); } }"},{"h2":"","h3":"关于数据搜索","h4":"","name":"关于数据搜索-h3","content":"如果在树状表格中使用了搜索功能（Grid::filter、Grid\\Column::filter、Grid::quickSearch），为了让用户能搜索到想要的数据，则会取消只查最顶级数据的操作。   使用 查询过滤、列过滤器、快捷搜索 等搜索功能都会取消只查最顶级数据的操作，只有 筛选器 和 范围查询scope 等功能例外。   例如下面的代码开启了快捷搜索  class CategoryController extends AdminController { protected function grid() { return Grid::make(new Category(), function (Grid $grid) { $grid->id('ID')->bold()->sortable(); $grid->title->tree(); // 开启树状表格功能 $grid->order->orderable(); // 开启排序功能 $grid->quickSearch(['id', 'title']); ...; }); } }  且用户在浏览器中使用了快捷搜索，则产生sql如下  select count(*) as aggregate from `demo_categories` where `id` like \"%xxx%\" or `title` like \"%xxx%\" select * from `demo_categories` where `id` like \"%xxx%\" or `title` like \"%xxx%\" order by `order` asc, `id` asc limit 20 offset 0"},{"h2":"","h3":"与模型树功能的差别","h4":"","name":"与模型树功能的差别-h3","content":"模型树同样可用于展示多层级结构数据，并且支持用拖拽的方式实现数据的层级、排序等操作，但是不支持分页和点击加载功能，只能一次性加载完所有数据， 因此模型树并不适合用来展示数据量较大的数据。  而树状表格支持分页和点击加载功能，适合用来展示数据量较大的多层级结构数据，但不支持用拖拽的方式实现数据的层级、排序操作。"}]},{"title":"表格基本使用","link":"model-grid","nodes":[{"h2":"简单示例","h3":"","h4":"","name":"简单示例-h2","content":"Dcat\\Admin\\Grid类用于生成基于数据模型的表格，先来个例子，数据库中有movies表  CREATE TABLE `movies` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `director` int(10) unsigned NOT NULL, `describe` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `rate` tinyint unsigned NOT NULL, `released` enum(0, 1), `release_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;   对应的数据模型为App\\Models\\Movie，对应的数据仓库为App\\Admin\\Repositories\\Movie，数据仓库代码如下：   如果你的数据来自MySQL，则数据仓库不是必须的，你也可以直接使用Model。   <?php namespace App\\Admin\\Repositories; use Dcat\\Admin\\Repositories\\EloquentRepository; use App\\Models\\Movie as MovieModel; class Movie extends EloquentRepository { protected $eloquentClass = MovieModel::class; /** * 设置表格查询的字段，默认查询所有字段 * * @return array */ public function getGridColumns(){ return ['id', 'title', 'director', 'rate', ...]; } }  下面的代码可以生成表movies的数据表格：  use App\\Admin\\Repositories\\Movie; use Dcat\\Admin\\Grid; $grid = Grid::make(new Movie(), function (Grid $grid) { // 第一列显示id字段，并将这一列设置为可排序列 $grid->id('ID')->sortable(); // 第二列显示title字段，由于title字段名和Grid对象的title方法冲突，所以用Grid的column()方法代替 $grid->title; // 第三列显示director字段，通过display($callback)方法设置这一列的显示内容为users表中对应的用户名 $grid->director->display(function($userId) { return User::find($userId)->name; }); // 第四列显示为describe字段 $grid->describe; // 第五列显示为rate字段 $grid->rate; // 第六列显示released字段，通过display($callback)方法来格式化显示输出 $grid->released('上映?')->display(function ($released) { return $released ? '是' : '否'; }); // 下面为三个时间字段的列显示 $grid->release_at; $grid->created_at; $grid->updated_at; // filter($callback)方法用来设置表格的简单搜索框 $grid->filter(function ($filter) { // 设置created_at字段的范围查询 $filter->between('created_at', 'Created Time')->datetime(); }); });"},{"h2":"基本使用方法","h3":"添加列","h4":"","name":"添加列-h3","content":" 通过$grid->username('用户名');的方式添加列时IDE默认是没有自动补全的，这时候可以通过php artisan admin::ide-helper生成IDE提示文件，具体请参考IDE自动补全。   // 直接通过字段名`username`添加列 $grid->username('用户名'); // 效果和上面一样 $grid->column('username', '用户名'); // 或者用属性的方式 // 没有设置label，会自动用翻译文件的翻译，具体请参照“字段翻译”章节 $grid->username; // 添加多列 $grid->columns('email', 'username' ...);"},{"h2":"基本使用方法","h3":"修改来源数据","h4":"","name":"修改来源数据-h3","content":"$grid->model()->where('id', '>', 100); $grid->model()->orderBy('id', 'desc'); $grid->model()->onlyTrashed(); ...  其它查询方法可以参考eloquent的查询方法."},{"h2":"基本使用方法","h3":"修改显示输出","h4":"","name":"修改显示输出-h3","content":"$grid->text()->display(function($text) { return str_limit($text, 30, '...'); }); // 允许混合使用多个“display”方法 $grid->name()->display(function ($name) { return \"<b>$name</b>\"; })->display(function ($name) { return \"<span class='label'>$name</span>\"; }); $grid->email->display(function ($email) { return \"mailto:$email\"; }); // 可以直接写字符串 $grid->username->display('...'); // 添加不存在的字段 $grid->column_not_in_table->display(function () { return 'blablabla....'; });  display()方法接收的匿名函数绑定了当前行的数据对象，可以在里面调用当前行的其它字段数据  $grid->first_name(); $grid->last_name(); // 不存的字段列 $grid->column('full_name')->display(function () { return $this->first_name.' '.$this->last_name; });"},{"h2":"基本使用方法","h3":"设置表格外层容器","h4":"","name":"设置表格外层容器-h3","content":" // 更改表格外层容器 $grid->wrap(function (Renderable $view) { $tab = Tab::make(); $tab->add('示例', $view); $tab->add('代码', $this->code(), true); return $tab; });"},{"h2":"基本使用方法","h3":"设置创建按钮","h4":"","name":"设置创建按钮-h3","content":"此功能默认开启  // 禁用 $grid->disableCreateButton(); // 显示 $grid->showCreateButton();"},{"h2":"基本使用方法","h3":"设置创建按钮","h4":"开启弹窗创建表单","name":"开启弹窗创建表单-h4","content":"此功能默认不开启  $grid->enableDialogCreate();"},{"h2":"基本使用方法","h3":"设置查询过滤器","h4":"","name":"设置查询过滤器-h3","content":"此功能默认开启  // 禁用 $grid->disableFilter(); // 显示 $grid->showFilter(); // 禁用过滤器按钮 $grid->disableFilterButton(); // 显示过滤器按钮 $grid->showFilterButton();"},{"h2":"基本使用方法","h3":"设置行选择器","h4":"","name":"设置行选择器-h3","content":"// 禁用 $grid->disableRowSelector(); // 显示 $grid->showRowSelector();"},{"h2":"基本使用方法","h3":"设置行选择器","h4":"设置选择中行的标题字段key","name":"设置选择中行的标题字段key-h4","content":"如不设置，默认取 name、 title、 username中的一个。  $grid->first_name; ... $grid->rowSelector()->titleKey('first_name');"},{"h2":"基本使用方法","h3":"设置行选择器","h4":"设置checkbox选择框颜色","name":"设置checkbox选择框颜色-h4","content":"默认 primary，支持：default、 primary、 success、 info、 danger、 purple、 inverse。  $grid->rowSelector()->style('success');"},{"h2":"基本使用方法","h3":"设置行选择器","h4":"点击当前行任意位置选中","name":"点击当前行任意位置选中-h4","content":"此功能默认不开启。  $grid->rowSelector()->click();"},{"h2":"基本使用方法","h3":"设置行选择器","h4":"设置选中行的背景颜色","name":"设置选中行的背景颜色-h4","content":"use Dcat\\Admin\\Widgets\\Color; $grid->rowSelector()->background(Color::dark20());"},{"h2":"基本使用方法","h3":"设置行选择器","h4":"设置checkbox选择框形状","name":"设置checkbox选择框形状-h4","content":"默认圆形。  // 设置为正方形 $grid->rowSelector()->circle(false);"},{"h2":"基本使用方法","h3":"设置行操作按钮","h4":"","name":"设置行操作按钮-h3","content":"// 禁用 $grid->disableActions(); // 显示 $grid->showActions(); // 禁用详情按钮 $grid->disableViewButton(); // 显示详情按钮 $grid->showViewButton(); // 禁用编辑按钮 $grid->disableEditButton(); // 显示编辑按钮 $grid->showEditButton(); // 禁用快捷编辑按钮 $grid->disableQuickEditButton(); // 显示快捷编辑按钮 $grid->showQuickEditButton(); // 禁用删除按钮 $grid->disableDeleteButton(); // 显示删除按钮 $grid->showDeleteButton(); "},{"h2":"基本使用方法","h3":"设置批量操作按钮","h4":"","name":"设置批量操作按钮-h3","content":"// 禁用 $grid->disableBatchActions(); // 显示 $grid->showBatchActions(); // 禁用批量删除按钮 $grid->disableBatchDelete(); // 显示批量删除按钮 $grid->showBatchDelete();"},{"h2":"基本使用方法","h3":"设置工具栏","h4":"","name":"设置工具栏-h3","content":"// 禁用 $grid->disableToolbar(); // 显示 $grid->showToolbar();"},{"h2":"基本使用方法","h3":"设置刷新按钮","h4":"","name":"设置刷新按钮-h3","content":"// 禁用 $grid->disableRefreshButton(); // 显示 $grid->showRefreshButton();"},{"h2":"基本使用方法","h3":"设置分页功能","h4":"","name":"设置分页功能-h3","content":"// 禁用 $grid->disablePagination(); // 显示 $grid->showPagination();"},{"h2":"基本使用方法","h3":"设置分页功能","h4":"设置每页显示行数","name":"设置每页显示行数-h4","content":"// 默认为每页20条 $grid->paginate(15);"},{"h2":"基本使用方法","h3":"设置分页功能","h4":"设置分页选择器选项","name":"设置分页选择器选项-h4","content":"$grid->perPages([10, 20, 30, 40, 50]); // 禁用分页选择器 $grid->disablePerPages();"},{"h2":"关联模型","h3":"一对一","h4":"","name":"一对一-h3","content":"users表和profiles表通过profiles.user_id字段生成一对一关联  CREATE TABLE `users` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `email` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; CREATE TABLE `profiles` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `user_id` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `age` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `gender` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;  对应的数据模以及数据仓库分别为:  // 模型 class User extends Model { public function profile() { return $this->hasOne(Profile::class); } } class Profile extends Model { public function user() { return $this->belongsTo(User::class); } } // 数据仓库 use App\\Models\\User as UserModel; class User extends EloquentRepository { protected $eloquentClass = UserModel::class; }   通过下面的代码可以关联在一个grid里面:  use Dcat\\Admin\\Grid; $grid = Grid::make(new User(), function (Grid $grid) { // 关联 profile 表数据 $grid->model()->with('profile'); $grid->id('ID')->sortable(); $grid->name(); $grid->email(); $grid->column('profile.age'); $grid->column('profile.gender'); //or $grid->profile()->age(); $grid->profile()->gender(); $grid->created_at(); $grid->updated_at(); });"},{"h2":"关联模型","h3":"一对多","h4":"","name":"一对多-h3","content":"posts表和comments表通过comments.post_id字段生成一对多关联  CREATE TABLE `posts` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `content` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; CREATE TABLE `comments` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `post_id` int(10) unsigned NOT NULL, `content` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;  对应的数据模和数据仓库分别为:  class Post extends Model { public function comments() { return $this->hasMany(Comment::class); } } class Comment extends Model { public function post() { return $this->belongsTo(Post::class); } } // 数据仓库 use App\\Models\\Post as PostModel; class Post extends EloquentRepository { protected $eloquentClass = PostModel::class; } use App\\Models\\Comment as CommentModel; class Comment extends EloquentRepository { protected $eloquentClass = CommentModel::class; }  通过下面的代码可以让两个模型在grid里面互相关联:  // Post $grid = Grid::make(new Post(), function (Grid $grid) { // 关联 comment 表数据 $grid->model()->with('comments'); $grid->id('id')->sortable(); $grid->title(); $grid->content(); $grid->comments('评论数')->display(function ($comments) { $count = count($comments); return \"<span class='label label-warning'>{$count}</span>\"; }); $grid->created_at(); $grid->updated_at(); });  // Comment // 关联 post 表数据 $grid = new Grid(new Comment('post')); $grid->id('id'); $grid->post()->title(); $grid->content(); $grid->created_at()->sortable(); $grid->updated_at();"},{"h2":"关联模型","h3":"多对多","h4":"","name":"多对多-h3","content":"users和roles表通过中间表role_users产生多对多关系  CREATE TABLE `users` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `username` varchar(190) COLLATE utf8_unicode_ci NOT NULL, `password` varchar(60) COLLATE utf8_unicode_ci NOT NULL, `name` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `created_at` timestamp NULL DEFAULT NULL, `updated_at` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `users_username_unique` (`username`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci CREATE TABLE `roles` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(50) COLLATE utf8_unicode_ci NOT NULL, `slug` varchar(50) COLLATE utf8_unicode_ci NOT NULL, `created_at` timestamp NULL DEFAULT NULL, `updated_at` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `roles_name_unique` (`name`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci CREATE TABLE `role_users` ( `role_id` int(11) NOT NULL, `user_id` int(11) NOT NULL, `created_at` timestamp NULL DEFAULT NULL, `updated_at` timestamp NULL DEFAULT NULL, KEY `role_users_role_id_user_id_index` (`role_id`,`user_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci  对应的数据模和数据仓库分别为:  class User extends Model { public function roles() { return $this->belongsToMany(Role::class); } } class Role extends Model { public function users() { return $this->belongsToMany(User::class); } } // 数据仓库 use App\\Models\\User as UserModel; class User extends EloquentRepository { protected $eloquentClass = UserModel::class; }  通过下面的代码可以让两个模型在grid里面互相关联:  // 关联 role 表数据 $grid = Grid::make(new User('roles'), function (Grid $grid) { $grid->id('ID')->sortable(); $grid->username(); $grid->name(); $grid->roles()->pluck('name')->label(); $grid->created_at(); $grid->updated_at(); });"}]},{"title":"数据仓库","link":"model-repository","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"Dcat Admin 构建页面不再直接依赖于Model，页面的构建与数据的读写是分开的。 换句话说，构建页面是不需要关心数据的读写的，我把对数据的读写操作抽象成清晰易懂的接口，只需实现这些简单、清晰的接口就能轻松切换数据源。 当然为了方便系统也保留了直接使用 Model 的功能，毕竟大多数时候直接使用 Model 也能满足我们的需求。 数据仓库是对数据的CURD操作抽象而成的接口，开发者通过实现Repository接口即可对数据进行CURD操作。 这样做的好处是可以把数据和界面的构建完全解耦分离，数据源的改变完全不影响界面的构建，开发者只需实现不同的Repository接口即可实现对多数据源的支持。 数据表格Grid、数据表单Form、数据详情Show、Tree 等组件不再直接依赖于Model，而是依赖于提供更简单清晰的接口的数据仓库，下面是Repository的所有接口： <?php namespace Dcat\\Admin\\Contracts; use Dcat\\Admin\\Form; use Dcat\\Admin\\Grid; use Dcat\\Admin\\Show; use Illuminate\\Support\\Collection; interface Repository { /** * 获取主键名称. * * @return string */ public function getKeyName(); /** * 获取创建时间字段. * * @return string */ public function getCreatedAtColumn(); /** * 获取更新时间字段. * * @return string */ public function getUpdatedAtColumn(); /** * 是否使用软删除. * * @return bool */ public function isSoftDeletes(); /** * 获取Grid表格数据. * * @param Grid\\Model $model * * @return \\Illuminate\\Contracts\\Pagination\\LengthAwarePaginator|Collection|array */ public function get(Grid\\Model $model); /** * 获取编辑页面数据. * * @param Form $form * * @return array */ public function edit(Form $form): array; /** * 获取详情页面数据. * * @param Show $show * * @return array */ public function detail(Show $show): array; /** * 新增记录. * * @param Form $form * * @return mixed */ public function store(Form $form); /** * 查询更新前的行数据. * * @param Form $form * * @return array */ public function getDataWhenUpdating(Form $form): array; /** * 更新数据. * * @param Form $form * * @return bool */ public function update(Form $form); /** * 删除数据. * * @param Form $form * @param array $deletingData * * @return mixed */ public function destroy(Form $form, array $deletingData); /** * 查询删除前的行数据. * * @param Form $form * * @return array */ public function getDataWhenDeleting(Form $form): array; } 如果你的数据是多层级结构，则还需要实现以下接口 <?php namespace Dcat\\Admin\\Contracts; interface TreeRepository { /** * 获取主键字段名称. * * @return string */ public function getPrimaryKeyColumn(); /** * 获取父级ID字段名称. * * @return string */ public function getParentColumn(); /** * 获取标题字段名称. * * @return string */ public function getTitleColumn(); /** * 获取排序字段名称. * * @return string */ public function getOrderColumn(); /** * 保存层级数据排序. * * @param array $tree * @param int $parentId */ public function saveOrder($tree = [], $parentId = 0); /** * 设置数据查询回调. * * @param \\Closure|null $query * * @return $this */ public function withQuery($queryCallback); /** * 获取层级数据. * * @return array */ public function toTree(); }"},{"h2":"Repository接口","h3":"getKeyName","h4":"","name":"getKeyName-h3","content":"此接口要求返回数据的主键字段名称，需要返回string类型值。   public function getKeyName() { return 'id'; }"},{"h2":"Repository接口","h3":"getCreatedAtColumn","h4":"","name":"getCreatedAtColumn-h3","content":"此接口要求返回数据的created_at字段名称，如果没有值可以返回空字符串或null值。   // 如果没有值可以返回空字符串或`null`值 public function getCreatedAtColumn() { return 'created_at'; }"},{"h2":"Repository接口","h3":"getUpdatedAtColumn","h4":"","name":"getUpdatedAtColumn-h3","content":"此接口要求返回数据的updated_at字段名称，如果没有值可以返回空字符串或null值。   // 如果没有值可以返回空字符串或`null`值 public function getCreatedAtColumn() { return 'updated_at'; }"},{"h2":"Repository接口","h3":"isSoftDeletes","h4":"","name":"isSoftDeletes-h3","content":"此接口要求返回数据是否支持软删除，请返回一个bool类型的值。   public function isSoftDeletes() { return true; }"},{"h2":"Repository接口","h3":"get","h4":"","name":"get-h3","content":"此接口要求返回数据表格Grid的数据，用于数据表格展示，要求返回一个array、Illuminate\\Support\\Collection或LengthAwarePaginator类型值。"},{"h2":"Repository接口","h3":"get","h4":"分页","name":"分页-h4","content":"当数据需要分页时要求返回一个\\Illuminate\\Contracts\\Pagination\\LengthAwarePaginator类型值：   public function get(Grid\\Model $model) { // 获取当前页数 $currentPage = $model->getCurrentPage(); // 获取每页显示行数 $perPage = $model->getPerPage(); // 获取筛选参数 $city = $model->getFilter()->input(Grid\\Filter\\Scope::QUERY_NAME, '广州'); $start = ($currentPage - 1) * $perPage; $client = new \\GuzzleHttp\\Client(); $response = $client->get(\"{$this->api}?{$this->apiKey}&city=$city&start=$start&count=$perPage\"); $data = json_decode((string)$response->getBody(), true); $paginator = new LengthAwarePaginator( $data['subjects'] ?? [], $data['total'] ?? 0, $perPage, // 传入每页显示行数 $currentPage // 传入当前页码 ); $paginator->setPath(\\url()->current()); return $paginator; }"},{"h2":"Repository接口","h3":"get","h4":"不分页","name":"不分页-h4","content":"如果不需要分页，则直接返回一个array或Illuminate\\Support\\Collection类型值即可。   public function get(Grid\\Model $model) { return [ ['id' => 1, 'name' => 'n1'], ['id' => 2, 'name' => 'n2'] ]; }"},{"h2":"Repository接口","h3":"edit","h4":"","name":"edit-h3","content":"此接口要求返回表单编辑页面的数据，用于显示数据表单编辑页面，需要返回array类型值。   public function edit(Form $form): array { // 获取数据主键值 $id = $form->getKey(); return ['id' => 1, 'name' => 'n1']; }"},{"h2":"Repository接口","h3":"detail","h4":"","name":"detail-h3","content":"此接口要求返回数据详情页面的数据，用于显示数据详情，需要返回array类型值。   public function detail(Show $show): array { // 获取数据主键值 $id = $show->getId(); return ['id' => 1, 'name' => 'n1']; }"},{"h2":"Repository接口","h3":"store","h4":"","name":"store-h3","content":"此接口用于新增一条记录，可以返回int、string或bool类型值。   public function store(Form $form) { // 获取待新增的数据 $attributes = $form->getUpdates(); // 执行你的新增逻辑 // 返回新增记录id或bool值 return 1; }"},{"h2":"Repository接口","h3":"getDataWhenUpdating","h4":"","name":"getDataWhenUpdating-h3","content":"此接口用于数据表单修改数据时查询原始记录，需要返回array类型值。   此接口只有某些特殊字段会用到，如图片、文件上传字段，当更改了图片或文件时可以根据这个接口查出的数据删除旧文件。所以如果你的表单中没有用到此类特殊字段，此接口可以返回一个空数组。    public function getDataWhenUpdating(Form $form): array { // 获取数据主键值 $id = $form->getKey(); return ['id' => 1, 'name' => 'n1']; }"},{"h2":"Repository接口","h3":"update","h4":"","name":"update-h3","content":"此接口用于数据表单修改记录，可以返回int、string或bool类型值。   public function update(Form $form) { // 获取待编辑的数据 $attributes = $form->getUpdates(); // 执行你的编辑逻辑 // 返回成功 return true; }"},{"h2":"Repository接口","h3":"getDataWhenDeleting","h4":"","name":"getDataWhenDeleting-h3","content":"此接口用于删除数据时查询原始记录，需要返回二维数组。   public function getDataWhenDeleting(Form $form): array { // 当批量删除时id为多个 $id = explode(',', $form->getKey()); // 执行你的逻辑 // 注意这里需要返回二维数组 return [ ['id' => 1, 'name' => 'h1'], ]; }"},{"h2":"Repository接口","h3":"destroy","h4":"","name":"destroy-h3","content":"此接口用于删除数据时查询原始记录，需要返回二维数组。   public function destroy(Form $form, array $deletingData) { // 当批量删除时id为多个 $id = explode(',', $form->getKey()); // $deletingData 是 getDataWhenDeleting 接口返回的数据 // 执行你的逻辑 // 注意这里需要返回二维数组 return true; }"},{"h2":"TreeRepository接口","h3":"getPrimaryKeyColumn","h4":"","name":"getPrimaryKeyColumn-h3","content":"此接口用于返回数据的主键字段名称，需要返回string类型值。   public function getPrimaryKeyColumn() { return $this->getKeyName(); }"},{"h2":"TreeRepository接口","h3":"getParentColumn","h4":"","name":"getParentColumn-h3","content":"此接口用于返回数据的父ID字段名称，需要返回string类型值。   public function getParentColumn() { return 'parent_id'; }"},{"h2":"TreeRepository接口","h3":"getTitleColumn","h4":"","name":"getTitleColumn-h3","content":"此接口用于返回数据标题字段名称，需要返回string类型值。   public function getTitleColumn() { return 'title'; }"},{"h2":"TreeRepository接口","h3":"getOrderColumn","h4":"","name":"getOrderColumn-h3","content":"此接口用于返回数据排序字段名称，需要返回string类型值。   此字段不是必须的，如果你的数据不支持或不需要排序，请返回空值！    public function getOrderColumn() { return 'order'; }"},{"h2":"TreeRepository接口","h3":"saveOrder","h4":"","name":"saveOrder-h3","content":"此接口用于保存层级数据的排序，并且接收两个参数   $tree array 此字段是一个已分好层级的数组 $parentId int 此字段主要用于递归时传递父ID使用    如果你的数据不支持 MySQL，可参考 Dcat\\Admin\\Traits\\ModelTree::saveOrder 方法自行实现。   $tree = [ [ 'id' => 1, 'title' => 'title', 'parent_id' => 0, 'children' => [ [ 'id' => 2, 'title' => 'child1', 'parent_id' => 1, ], [ 'id' => 3, 'title' => 'child2', 'parent_id' => 1, ], ], ] ]; // 保存排序，内层逻辑请自行实现 $repository->saveOrder($tree); "},{"h2":"TreeRepository接口","h3":"withQuery","h4":"","name":"withQuery-h3","content":"此接口需结合 toTree 接口使用，接收一个参数：主要用于设置数据查询操作的相关回调或参数。  <?php use Dcat\\Admin\\Contracts\\Repository; use Dcat\\Admin\\Contracts\\TreeRepository; use Dcat\\Admin\\Support\\Helper; class Category implements Repository, TreeRepository { protected $queryCallbacks = []; public function withQuery($queryCallback) { $this->queryCallbacks[] = $queryCallback; return $this; } public function toTree() { // 这里演示的代码只是为了说明 withQuery 方法的作用 $client = ...; foreach ($this->queryCallbacks as $callback) { $callback($client); } return Helper::buildNestedArray($client->get()); } } "},{"h2":"TreeRepository接口","h3":"toTree","h4":"","name":"toTree-h3","content":"此接口主要用于查询数据并分好层级返回，需要返回 array 类型值。   public function toTree() { $client = ...; foreach ($this->queryCallbacks as $callback) { $callback($client); } return Helper::buildNestedArray($client->get()); }"},{"h2":"模型","h3":"","h4":"","name":"模型-h2","content":"Dcat Admin已经内置了对Eloquent的支持，如果你的数据源是支持Model的，那么只需继承Dcat\\Admin\\Repositories\\EloquentRepository类即可实现对数据的CURD操作，如：  <?php namespace App\\Admin\\Repositories; use Dcat\\Admin\\Repositories\\EloquentRepository; use App\\Models\\Movie as MovieModel; class Movie extends EloquentRepository { // 这里设置你的模型类名即可 protected $eloquentClass = MovieModel::class; // 通过这个方法可以指定查询的字段，默认\"*\" public function getGridColumns() { return [$this->getKeyName(), 'name', 'title', 'created_at']; } // 通过这个方法可以指定表单页查询的字段，默认\"*\" public function getFormColumns() { return [$this->getKeyName(), 'name', 'title', 'created_at']; } // 通过这个方法可以指定数据详情页查询的字段，默认\"*\" public function getDetailColumns() { return ['*']; } }"}]},{"title":"详情字段显示扩展","link":"model-show-extend","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"这个功能用来扩展详情字段显示, 在内置的显示方法不满足需求的情况下，可以使用这个功能来实现 首先定义扩展类： <?php namespace App\\Admin\\Extensions\\Show; use Dcat\\Admin\\Show\\AbstractField; class UnSerialize extends AbstractField { public function render($arg = '') { // 返回任意可被渲染的内容 return unserialize($this->value); } } 然后在app/Admin/bootstrap.php中注册扩展类 use Dcat\\Admin\\Show\\Field; use App\\Admin\\Extensions\\Show\\UnSerialize; Field::extend('unserialize', UnSerialize::class); 然后在控制器中使用这个扩展 $show->column()->unserialize('xxx'); 传入unserialize()方法的参数会按顺序传入UnSerialize::render()方法中。 在父类Dcat\\Admin\\Show\\AbstractField中可以看到几个常用的属性 /** * Field value. * * @var mixed */ protected $value; /** * Current field model. * * @var Fluent */ protected $model; /** * If this field show with a border. * * @var bool */ public $border = true; /** * If this field show escaped contents. * * @var bool */ public $escape = true; 其中$value和$model分别是当前字段值和当前详情内容的数据，在render()方法中可以用来获取你想要的数据。 $border用来控制当前显示内容是否需要外边框，$escape分别用来设置当前显示内容要不要HTML转义。"}]},{"title":"字段显示","link":"model-show-field","nodes":[{"h2":"","h3":"分隔线","h4":"","name":"分隔线-h3","content":"如果要在字段之间添加一条分隔线：  $show->divider();"},{"h2":"","h3":"换行","h4":"","name":"换行-h3","content":"如果要在字段之间使用换行：  $show->newline();"},{"h2":"","h3":"修改显示内容","h4":"","name":"修改显示内容-h3","content":"用下面的方法修改显示内容  $show->title()->as(function ($title) { return \"<{$title}>\"; }); $show->contents()->as(function ($content) { return \"<pre>{$content}</pre>\"; });"},{"h2":"","h3":"帮助方法","h4":"","name":"帮助方法-h3","content":"帮助方法与数据表格字段帮助方法使用一致，可参考帮助方法。"},{"h2":"","h3":"内置显示扩展方法","h4":"","name":"内置显示扩展方法-h3","content":"下面是通过as方法内置实现的几个常用的显示样式："},{"h2":"","h3":"内置显示扩展方法","h4":"view","name":"view-h4","content":"view方法可以引入一个视图文件。  // 模板中接收以下三个变量： // name 字段名称 // value 字段值 // model 当前行数据 $show->content->view('admin.fields.content');"},{"h2":"","h3":"内置显示扩展方法","h4":"explode","name":"explode-h4","content":"explode方法可以把字符串分割为数组。  $show->tag->explode()->label(); // 可以指定分隔符，默认\",\" $show->tag->explode('|')->label();"},{"h2":"","h3":"内置显示扩展方法","h4":"prepend","name":"prepend-h4","content":"// 当字段值是一个字符串 $show->email->prepend('mailto:'); // 当字段值是一个数组 $show->arr->prepend('first item');"},{"h2":"","h3":"内置显示扩展方法","h4":"append","name":"append-h4","content":"// 当字段值是一个字符串 $show->email->append('@gmail.com'); // 当字段值是一个数组 $show->arr->append('last item');"},{"h2":"","h3":"内置显示扩展方法","h4":"image","name":"image-h4","content":"字段avatar的内容是图片的路径或者url，可以将它显示为图片：  $show->avatar()->image();  image()方法的参数参考Field::image()"},{"h2":"","h3":"内置显示扩展方法","h4":"file","name":"file-h4","content":"字段document的内容是文件的路径或者url，可以将它显示为文件：  $show->avatar()->file();  file()方法的参数参考Field::file()"},{"h2":"","h3":"内置显示扩展方法","h4":"link","name":"link-h4","content":"字段homepage的内容是url链接，可以将它显示为HTML链接：  $show->homepage()->link();  link()方法的参数参考Field::link()"},{"h2":"","h3":"内置显示扩展方法","h4":"label","name":"label-h4","content":"将字段tag的内容显示为label：  $show->tag()->label();  label()方法的参数参考Field::label()"},{"h2":"","h3":"内置显示扩展方法","h4":"badge","name":"badge-h4","content":"将字段rate的内容显示为badge：  $show->rate()->badge();  badge()方法的参数参考Field::badge()"},{"h2":"","h3":"内置显示扩展方法","h4":"using","name":"using-h4","content":"如果字段gender的取值为f、m，分别需要用女、男来显示  $show->gender()->using(['f' => '女', 'm' => '男']);"},{"h2":"","h3":"内置显示扩展方法","h4":"图片轮播","name":"图片轮播-h4","content":"如果字段值为图片数组，可以用下面的调用显示为图片轮播组件  $show->field('images')->carousel(); // 设置显示尺寸和图片服务器 $show->field('images')->carousel($width = 300, int $height = 200, $server);"},{"h2":"","h3":"内置显示扩展方法","h4":"显示文件尺寸","name":"显示文件尺寸-h4","content":"如果字段数据是表示文件大小的字节数，可以通过调用filezise方法来显示更有可读性的文字  $show->field('file_size')->filesize();  这样数值199812019将会显示为190.56 MB"}]},{"title":"数据详情初始化","link":"model-show-init","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"通过Show::resolving方法设置的回调函数会在Dcat\\Admin\\Show类被实例化时触发； 通过Show::composing方法设置的回调函数会在render()方法被调用时触发； 开发者可以在这两个事件中改变Show的一些设置或行为，比如需要禁用掉某些操作，可以在app/Admin/bootstrap.php加入下面的代码： use Dcat\\Admin\\Show; Show::resolving(function (Show $show) { $show->showQuickEdit(); });"}]},{"title":"关联关系","link":"model-show-relation","nodes":[{"h2":"一对一","h3":"","h4":"","name":"一对一-h2","content":"users表和上面的posts表为一对一关联关系，通过posts.author_id字段关联，users表结构如下：  CREATE TABLE `users` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `email` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;  模型定义为：  class User extends Model { } class Post extends Model { public function author() { return $this->belongsTo(User::class, 'author_id'); } }  数据仓库定义为：  <?php namespace App\\Admin\\Repositories; use Dcat\\Admin\\Repositories\\EloquentRepository; use User as UserModel; class User extends EloquentRepository { protected $eloquentClass = UserModel::class; }  那么可以用下面的方式显示post所属的用户的详细：  use App\\Admin\\Repositories\\User; $show->author(function ($model) { $show = new Show(new User); $show->setId($model->author_id); $show->resource('/users'); $show->id(); $show->name(); $show->email(); return $show; });  注意：为了能够正常使用这个面板右上角的工具，必须用resource方法设置用户资源的url访问路径"},{"h2":"一对多","h3":"","h4":"","name":"一对多-h2","content":"一对多会以数据表格的方式呈现，下面是简单的例子  posts表和评论表comments为一对多关系(一条post有多条comments)，通过comments.post_id字段关联  CREATE TABLE `comments` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `post_id` int(10) unsigned NOT NULL, `content` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci  模型定义为：  class Post extends Model { public function comments() { return $this->hasMany(Comment::class); } } class Comment extends Model { }  数据仓库定义为：  <?php namespace App\\Admin\\Repositories; use Dcat\\Admin\\Repositories\\EloquentRepository; use Comment as CommentModel; class Comment extends EloquentRepository { protected $eloquentClass = CommentModel::class; }  那么评论的显示通过下面的代码实现：  use App\\Admin\\Repositories\\Comment; $show->comments(function ($model) { $grid = new Grid(new Comment); $grid->model()->where('post_id', $model->id); $grid->resource('/admin/comments'); $grid->id(); $grid->content()->limit(10); $grid->created_at(); $grid->updated_at(); $grid->filter(function ($filter) { $filter->like('content')->width('300px'); }); return $grid; });  注意：为了能够正常使用这个数据表格的功能，必须用resource()方法设置comments资源的url访问路径"},{"h2":"多对多","h3":"","h4":"","name":"多对多-h2","content":"多对多会以数据表格的方式呈现，下面是简单的例子  角色表roles和权限表permissions为多对多关系，通过中间表role_permissions关联  CREATE TABLE `roles` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(50) COLLATE utf8mb4_unicode_ci NOT NULL, `slug` varchar(50) COLLATE utf8mb4_unicode_ci NOT NULL, `created_at` timestamp NULL DEFAULT NULL, `updated_at` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `admin_roles_name_unique` (`name`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci; CREATE TABLE `permissions` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(50) COLLATE utf8mb4_unicode_ci NOT NULL, `slug` varchar(50) COLLATE utf8mb4_unicode_ci NOT NULL, `http_method` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL, `http_path` text COLLATE utf8mb4_unicode_ci, `order` int(11) NOT NULL DEFAULT '0', `parent_id` int(11) NOT NULL DEFAULT '0', `created_at` timestamp NULL DEFAULT NULL, `updated_at` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `admin_permissions_name_unique` (`name`) ) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci; CREATE TABLE `role_permissions` ( `role_id` int(11) NOT NULL, `permission_id` int(11) NOT NULL, `created_at` timestamp NULL DEFAULT NULL, `updated_at` timestamp NULL DEFAULT NULL, KEY `admin_role_permissions_role_id_permission_id_index` (`role_id`,`permission_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;  模型定义为：  class Role extends Model { public function permissions() : BelongsToMany { return $this->belongsToMany(Permission::class, 'role_permissions', 'role_id', 'permission_id'); } } class Permission extends Model { }  数据仓库定义为：  <?php namespace App\\Admin\\Repositories; use Dcat\\Admin\\Repositories\\EloquentRepository; use Permission as PermissionModel; class Permission extends EloquentRepository { protected $eloquentClass = PermissionModel::class; }  那么权限的显示通过下面的代码实现：  use App\\Admin\\Repositories\\Permission; $show->permissions(function ($model) { $grid = new Grid(new Permission); $grid->model()->join('role_permissions', function ($join) use ($model) { $join->on('role_permissions.permission_id', 'id') ->where('role_id', '=', $model->id); }); $grid->resource('auth/permissions'); $grid->id; $grid->name; $grid->slug; $grid->http_path; $grid->filter(function (Grid\\Filter $filter) { $filter->equal('id')->width('300px'); }); return $grid; });"}]},{"title":"数据详情字段翻译","link":"model-show-trans","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"与数据表格字段翻译的使用基本一致，可参考数据表格字段翻译。"}]},{"title":"数据详情基本使用","link":"model-show","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"Dcat\\Admin\\Show用来显示数据详情，先来个例子，数据库中有posts表： CREATE TABLE `posts` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `author_id` int(10) unsigned NOT NULL , `title` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `content` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `rate` int(255) COLLATE utf8_unicode_ci NOT NULL, `release_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; 对应的数据模型为App\\Models\\Post，数据仓库为App\\Admin\\Repositories\\Post，下面的代码可以显示posts表的数据详情： <?php namespace App\\Admin\\Controllers; use App\\Http\\Controllers\\Controller; use App\\Admin\\Repositories\\Post; use Dcat\\Admin\\Layout\\Content; use Dcat\\Admin\\Show; use Dcat\\Admin\\Admin; class PostController extends Controller { public function show($id, Content $content) { return $content->header('Post') ->description('详情') ->body(Admin::show($id, new Post, function (Show $show) { $show->id('ID'); $show->title('标题'); $show->content('内容'); $show->rate(); $show->created_at(); $show->updated_at(); $show->release_at(); })); } }"},{"h2":"基本使用方法","h3":"内容转义","h4":"","name":"内容转义-h3","content":"为了防止XSS攻击, 默认输出的内容都会使用HTML转义，如果你不想转义输出HTML，可以调用unescape方法：  $show->avatar()->unescape()->as(function ($avatar) { return \"<img src='{$avatar}' />\"; });"},{"h2":"基本使用方法","h3":"设置字段宽度","h4":"","name":"设置字段宽度-h3","content":"字段宽度默认值为“3”，可以设置1-12之间的数字。  $show->created_at->width(4);"},{"h2":"基本使用方法","h3":"修改面板的样式和标题","h4":"","name":"修改面板的样式和标题-h3","content":"$show->panel() ->style('danger') ->title('post基本信息...');  style的取值可以是primary、info、danger、warning、default"},{"h2":"基本使用方法","h3":"面板工具设置","h4":"","name":"面板工具设置-h3","content":"面板右上角默认有三个按钮编辑、删除、列表，可以分别用下面的方式关掉它们：  $show->panel() ->tools(function ($tools) { $tools->disableEdit(); $tools->disableList(); $tools->disableDelete(); // 显示快捷编辑按钮 $tools->showQuickEdit(); });"}]},{"title":"模型树","link":"model-tree","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"这个功能可以实现一个树状组件，可以用拖拽的方式实现数据的层级、排序等操作，下面是基本的用法。"},{"h2":"表结构和模型","h3":"","h4":"","name":"表结构和模型-h2","content":"要使用model-tree，要遵守约定的表结构：  CREATE TABLE `demo_categories` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `parent_id` int(11) NOT NULL DEFAULT '0', `order` int(11) NOT NULL DEFAULT '0', `title` varchar(50) COLLATE utf8_unicode_ci NOT NULL, `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci  上面的表格结构里面有三个必要的字段parent_id、order、title,其它字段没有要求。  对应的模型为app/Models/Category.php:  <?php namespace App\\Models\\Demo; use Dcat\\Admin\\Traits\\ModelTree; use Illuminate\\Database\\Eloquent\\Model; class Category extends Model { use ModelTree; protected $table = 'demo_categories'; }  表结构中的三个字段parent_id、order、title的字段名也是可以修改的：   为了便于阅读，这里不再展示 Repository 代码。   <?php namespace App\\Models\\Demo; use Dcat\\Admin\\Traits\\ModelTree; use Illuminate\\Database\\Eloquent\\Model; class Category extends Model { use ModelTree; protected $table = 'demo_categories'; public function __construct(array $attributes = []) { parent::__construct($attributes); $this->setParentColumn('pid'); $this->setOrderColumn('sort'); $this->setTitleColumn('name'); } }"},{"h2":"使用方法","h3":"","h4":"","name":"使用方法-h2","content":"然后就是在页面中使用model-tree了：  <?php namespace App\\Admin\\Controllers\\Demo; use App\\Http\\Controllers\\Controller; use App\\Models\\Category; use Dcat\\Admin\\Layout\\Row; use Dcat\\Admin\\Layout\\Content; use Dcat\\Admin\\Tree; class CategoryController extends Controller { public function index(Content $content) { return $content->header('树状模型') ->body(function (Row $row) { $tree = new Tree(new Category); $row->column(12, $tree); }); } }  可以通过下面的方式来修改行数据的显示：  $tree = new Tree(new Category); $tree->branch(function ($branch) { $src = config('admin.upload.host') . '/' . $branch['logo'] ; $logo = \"<img src='$src' style='max-width:30px;max-height:30px' class='img'/>\"; return \"{$branch['id']} - {$branch['title']} $logo\"; });  在回调函数中返回的字符串类型数据，就是在树状组件中的每一行的显示内容，$branch参数是当前行的数据数组。  如果要修改模型的查询，用下面的方式  $tree->query(function ($model) { return $model->where('type', 1); });"}]},{"title":"开发前必读","link":"notice","nodes":[{"h2":"","h3":"开发环境请打开debug模式","h4":"","name":"开发环境请打开debug模式-h3","content":"Dcat Admin提供一些开发工具（如代码生成器）需要在 debug 模式下才能使用。 建议开发者在开发环境打开debug模式，把.env配置文件中的参数APP_DEBUG值设置为true即可。"},{"h2":"","h3":"按需引入JS脚本","h4":"","name":"按需引入JS脚本-h3","content":"Dcat Admin 使用 jquery-pjax 构建无刷新页面（单页应用），并且支持按需加载 JS 脚本，支持在任意的页面方法（模板文件除外）中引入JS脚本，每个页面只需加载当前页面所需要使用到的 js 脚本。  示例：  定义一个卡片组件，这个组件需要引入一些前端静态资源文件  <?php use Illuminate\\Contracts\\Support\\Renderable; use Admin; class Card implements Renderable { public static $js = [ 'xxx/js/card.min.js', ]; public static $css = [ 'xxx/css/card.min.css', ]; public function script() { return <<<JS console.log('所有JS脚本都加载完了'); $('xxx').card(); JS; } public function render() { // 在这里可以引入你的js或css文件 Admin::js(static::$js); Admin::css(static::$css); // 需要在页面执行的JS代码 // 通过 Admin::script 设置的JS代码会自动在所有JS脚本都加载完毕后执行 Admin::script($this->script()); return view('...')->render(); } }  在控制器中使用这个组件  use Dcat\\Admin\\Layout\\Content; use Card; class HomeController { public function index(Content $content) { // 使用上面的Card组件 // Card组件需要用到的静态文件只会在当前请求加载 // 其他请求不会加载 return $content->body(new Card()); } }"},{"h2":"","h3":"在页面中添加JS代码","h4":"","name":"在页面中添加JS代码-h3","content":"由于加入了页面按需加载JS脚本的功能，所以在本项目内添加的JS代码都必须使用Dcat.ready方法监听JS脚本加载完毕事件，在此事件内的JS代码会在所有JS脚本都加载完毕后才执行。  使用 Dcat\\Admin\\Admin::script 方法添加的代码会自动放在Dcat.ready方法内执行。  <?php use Dcat\\Admin\\Admin; use Dcat\\Admin\\Layout\\Content; class UserController { public function index(Content $content) { Admin::script( <<<JS (function () { // 如果有定义局部变量的需求，最好放在匿名函数内，防止变量污染 var name = 'test'; console.log('所有JS脚本都加载完毕啦~~', name) })() JS ); return $content->header(...)->body(...); } }  如果是在模板文件中添加JS代码，则需要把代码放在Dcat.ready内执行  <script> // 用 Dcat.ready() 代替 $() // 此方法会在所有 js 脚本加载完成后执行 Dcat.ready(function () { // 写入你的 js 代码 console.log('所有 js 脚本加载完毕啦~~'); }); </script>"},{"h2":"","h3":"Bootstrap4公共样式","h4":"","name":"Bootstrap4公共样式-h3","content":"Dcat Admin采用bootstrap4的栅格系统对页面进行布局，即简单又强大。开始开发前需要对此有所了解，点此查看文档。  另外bootsrap4提供了非常多非常有用的公共样式，对编写页面组件非常有帮助，能显著提高开发效率，建议编写组件前先查阅一遍文档，以下是推荐学习的样式列表：  通过我们的显示实用程序，可以快速、有效地切换组件的显示值和更多，包括对一些更常见的值的支持，此样式列表对响应式布局非常有帮助。 引入新的Flex弹性布局，可以实现通过一整套响应灵活的实用程序，快速管理栅格的列、导航、组件等的布局、对齐和大小。通过进一度的定义CSS，还可以实现更复杂的展示样式。 通过颜色传达意义、表达不同的模块，这有一系列的定义方法，包括支持链接、悬停、选中等状态相关的的样式集。 使用我们的响应式float浮动通用样式，能在任何设备断点（浏览器尺寸）上切换浮动。 使用系统宽度和高度样式，轻松地定义任何元素的宽或高（相对于其父级） 内置了各种的快速缩进、隔离、填充等间距处理工具，响应余量和填充实用程序类来修改元素的外观。 用于控制文本的对齐、组合、字重等示例以及使用文档。 轻松更改内联、内嵌块、内联表和表格单元格元素的垂直对齐方式。"}]},{"title":"权限控制","link":"permission","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"Dcat Admin已经内置了RBAC权限控制模块，展开左侧边栏的Auth，下面有用户、角色、权限三项的管理面板，权限控制的使用如下："},{"h2":"路由控制","h3":"","h4":"","name":"路由控制-h2","content":"在Dcat Admin中，权限和路由是绑定在一起的，在编辑权限页面里面设置当前权限能访问的路由，在HTTP方法select框中选择访问路由的方法，在HTTP路径textarea中填写能访问的路径。  比如要添加一个权限，该权限可以以GET方式访问路径/admin/users，那么HTTP方法选择GET，HTTP路径填写/users。  如果要访问前缀是/admin/users的所有路径，那么HTTP路径填写/users*，如果权限包括多个访问路径，换行填写每条路径。"},{"h2":"页面控制","h3":"","h4":"","name":"页面控制-h2","content":"如果你要在页面中控制用户的权限，可以参考下面的例子"},{"h2":"页面控制","h3":"场景1","h4":"","name":"场景1-h3","content":"比如现在有一个场景，对文章发布模块做权限管理，以创建文章为例  首先创建一项权限，进入http://localhost/admin/auth/permissions，权限标识（slug）填写create-post，权限名称填写创建文章，这样权限就创建好了。 第二步可以把这个权限直接附加给个人或者角色，在用户编辑页面可以直接把上面创建好的权限附加给当前编辑用户，也可以在编辑角色页面附加给某个角色。 第三步，在创建文章控制器里面添加控制代码：  use Dcat\\Admin\\Auth\\Permission; class PostController extends Controller { public function create() { // 检查权限，有create-post权限的用户或者角色可以访问创建文章页面 Permission::check('create-post'); } }  这样就完成了一个页面的权限控制。"},{"h2":"页面控制","h3":"场景2","h4":"","name":"场景2-h3","content":"如果你要在表格中控制用户对元素的显示，那么需要先定义两个权限，比如权限标示delete-image、和view-title-column分别用来控制有删除图片的权限和显示某一列的权限，把这两个权限赋给你设置的角色，然后在grid中加入代码：  $grid->actions(function ($actions) { // 没有`delete-image`权限的角色不显示删除按钮 if (!Admin::user()->can('delete-image')) { $actions->disableDelete(); } }); // 只有具有`view-title-column`权限的用户才能显示`title`这一列 if (Admin::user()->can('view-title-column')) { $grid->column('title'); }"},{"h2":"相关方法","h3":"","h4":"","name":"相关方法-h2","content":"获取当前用户对象  Admin::user();  获取当前用户id  Admin::user()->id;  获取用户角色  Admin::user()->roles;  获取用户的权限  Admin::user()->permissions;  用户是否某个角色  Admin::user()->isRole('developer');  是否有某个权限  Admin::user()->can('create-post');  是否没有某个权限  Admin::user()->cannot('delete-post');  是否是超级管理员  Admin::user()->isAdministrator();  是否是其中的角色  Admin::user()->inRoles(['editor', 'developer']);"},{"h2":"权限中间件","h3":"","h4":"","name":"权限中间件-h2","content":"可以在路由配置上结合权限中间件来控制路由的权限   // 允许administrator、editor两个角色访问group里面的路由 Route::group([ 'middleware' => 'admin.permission:allow,administrator,editor', ], function ($router) { $router->resource('users', UserController::class); ... }); // 禁止developer、operator两个角色访问group里面的路由 Route::group([ 'middleware' => 'admin.permission:deny,developer,operator', ], function ($router) { $router->resource('users', UserController::class); ... }); // 有edit-post、create-post、delete-post三个权限的用户可以访问group里面的路由 Route::group([ 'middleware' => 'admin.permission:check,edit-post,create-post,delete-post', ], function ($router) { $router->resource('posts', PostController::class); ... });  权限中间件和其它中间件使用方法一致。"}]},{"title":"常见问题汇总","link":"qa","nodes":[{"h2":"关于前端资源问题","h3":"","h4":"","name":"关于前端资源问题-h2","content":"Dcat Admin是支持前端资源按需加载的，开发者无需担心安装组件过多影响页面加载速度。 开发者在需要用到某个组件的时候再引入前端资源即可，如果需要引入全局可用的前端资源，可以在app/Admin/bootstrap.php中引入：  Admin::css('path/to/your/css'); Admin::js('path/to/your/js');"},{"h2":"重写登陆页面和登陆逻辑","h3":"","h4":"","name":"重写登陆页面和登陆逻辑-h2","content":"在路由文件app/Admin/routes.php中，覆盖掉登陆页面和登陆逻辑的路由，即可实现自定义的功能  Route::group([ 'prefix' => config('admin.prefix'), 'namespace' => Admin::controllerNamespace(), 'middleware' => ['web', 'admin'], ], function (Router $router) { $router->get('auth/login', 'AuthController@getLogin'); $router->post('auth/login', 'AuthController@postLogin'); });   在自定义的路由器AuthController中的getLogin、postLogin方法里分别实现自己的登陆页面和登陆逻辑。  参考控制器文件AuthController.php，视图文件login.blade.php"},{"h2":"更新静态资源","h3":"","h4":"","name":"更新静态资源-h2","content":"如果遇到更新之后,部分组件不能正常使用,那有可能是dcat-admin自带的静态资源有更新了,需要运行命令php artisan vendor:publish --tag=dcat-admin-assets --force来重新发布前端资源，发布之后不要忘记清理浏览器缓存."}]},{"title":"快速开始","link":"quick-start","nodes":[{"h2":"数据表结构","h3":"","h4":"","name":"数据表结构-h2","content":"用Laravel自带的users表举例,表结构为：  CREATE TABLE `users` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `email` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `password` varchar(60) COLLATE utf8_unicode_ci NOT NULL, `remember_token` varchar(100) COLLATE utf8_unicode_ci DEFAULT NULL, `created_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', `updated_at` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00', PRIMARY KEY (`id`), UNIQUE KEY `users_email_unique` (`email`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci  对应的数据模型为文件 App\\User.php  dcat-admin可以通过使用以下几步来快速生成users表的CURD操作页面："},{"h2":"创建数据仓库","h3":"","h4":"","name":"创建数据仓库-h2","content":"创建文件app/Admin/Repositories/User.php并添加如下内容   如果你的数据来自MySQL，则数据仓库不是必须的，你也可以直接使用Model。 <?php   namespace App\\Admin\\Repositories;  use Dcat\\Admin\\Repositories\\EloquentRepository; use App\\User as UserModel;  class User extends EloquentRepository { /**   @var string */ protected $eloquentClass = UserModel::class; /** 设置表格查询的字段，默认查询所有字段 @return array */ public function getGridColumns(){ return ['id', 'name', 'email', 'created_at', 'updated_at']; } } "},{"h2":"创建控制器","h3":"","h4":"","name":"创建控制器-h2","content":"创建控制器文件app/Admin/Controllers/UserController.php，并写入如下内容：  <?php namespace App\\Admin\\Controllers; use Dcat\\Admin\\Form; use Dcat\\Admin\\Grid; use Dcat\\Admin\\Show; use App\\Admin\\Repositories\\User; use Dcat\\Admin\\Controllers\\AdminController; class UsersController extends AdminController { /** * Title for current resource. * * @var string */ protected $title = '用户'; /** * Make a grid builder. * * @return Grid */ protected function grid() { return Grid::make(new User(), function (Grid $grid) { $grid->id->bold()->sortable(); $grid->email; $grid->created_at; $grid->updated_at->sortable(); $grid->filter(function (Grid\\Filter $filter) { $filter->equal('id'); }); }); } /** * Make a show builder. * * @param mixed $id * @return Show */ protected function detail($id) { return Show::make($id, new User(), function (Show $show) { $show->id; $show->email; $show->created_at; $show->updated_at; }); } /** * Make a form builder. * * @return Form */ protected function form() { return Form::make(new User(), function (Form $form) { $form->display('id'); $form->text('email'); $form->display('created_at'); $form->display('updated_at'); }); } }"},{"h2":"添加路由配置","h3":"","h4":"","name":"添加路由配置-h2","content":"在dcat-admin的路由配置文件app/Admin/routes.php里添加一行：  $router->resource('users', 'UserController');"},{"h2":"添加左侧菜单","h3":"","h4":"","name":"添加左侧菜单-h2","content":"打开http://localhost:8000/admin/auth/menu，添加对应的menu, 然后就能在后台管理页面的左侧边栏看到用户管理页面的链接入口了。   其中uri填写不包含路由前缀的的路径部分，比如完整路径是http://localhost:8000/admin/demo/users, 那么就填demo/users，如果要添加外部链接，只要填写完整的url即可，比如http://dcat-admin.org/. "},{"h2":"添加左侧菜单","h3":"菜单翻译","h4":"","name":"菜单翻译-h3","content":"在您的语言文件的menu_titles索引中追加菜单标题。 例如“工作单位”标题：  在resources/lang/{当前语言}/admin.php中  ... // 用_小写并用_替换空格 'menu_titles' => [ 'work_units' => 'Unidades de trabajo' ],"},{"h2":"完成","h3":"","h4":"","name":"完成-h2","content":"一个简单的CURD功能页面就构建完成了，打开浏览器访问http://localhost:8000/admin/users即可。  剩下的工作就是构建数据表格和表单了，打开 app/Admin/Contollers/UserController.php,找到form()和grid()方法，然添加构建代码。 更多详细使用请查看数据表格和数据表单。"}]},{"title":"区块（section）","link":"section","nodes":[{"h2":"简介","h3":"","h4":"","name":"简介-h2","content":"Dcat Admin提供section功能允许开发者在项目运行时更改页面各个部分的内容，而不需要直接去修改模板。   Dcat Admin的section功能参考了Blade模板引擎的@section功能和Wordpress的add_filter功能，如果开发者理解这两者其中之一就能快速上手。 "},{"h2":"使用","h3":"admin_section","h4":"","name":"admin_section-h3","content":"输出section内容，此函数类似于Blade模板中的@yield指令以及WordPress中的apply_filters函数。  参数：   $section {string} 区块名称 $default {string|Closure} 默认值 $options {array} 参数，需要注意的是key值必须使用英文字母开头，否则无法被获取到   返回值：   {string}   echo admin_section('navigation', null, ['count' => 4]);"},{"h2":"使用","h3":"admin_inject_section","h4":"","name":"admin_inject_section-h3","content":"注入section内容，此函数类似WordPress中的add_filter函数。  参数：   $section {string} 区块名称 $content {string|Illuminate\\Contracts\\Support\\Renderable|Closure} 区块内容 $append {bool} 默认true，是否追加到上一个注入的内容后面，如果传false则会替换掉前面注入的内容 $priority {int} 默认10，优先级，值越大排序越靠前   当第二个参数传入的是匿名函数时，匿名函数接收一个Illuminate\\Support\\Fluent对象。匿名函数中接收一个Illuminate\\Support\\Fluent对象，此对象包含有前面注入到此区块的内容，通过previous属性可以获得；如果此section还有其他参数，也可以通过访问属性的方式获得，如下：  admin_inject_section('navigation', e(\"<navigation>1</navigation>\")); admin_inject_section('navigation', function ($options) { // 获取上一个注入此区块的内容 $previous = $options->previous; // 获取自定义参数 $count = $options->count; return e(\"<navigation>count:{$count}</navigation>\"); }, true, 11); // 输出 echo admin_section('navigation', null, ['count' => 4]); // 最终输出结果为 // <navigation>count:4</navigation><navigation>1</navigation>"},{"h2":"使用","h3":"admin_inject_default_section","h4":"","name":"admin_inject_default_section-h3","content":"注入默认内容，如果调用了admin_inject_section函数注入内容（无论是在前面还是后面都一样），则此函数不生效。  参数：   $section {string} 区块名称 $content {string|Illuminate\\Contracts\\Support\\Renderable|Closure} 区块内容，与admin_inject_section的第二个参数一致   admin_inject_default_section('navigation', '暂无数据');"},{"h2":"使用","h3":"admin_has_section","h4":"","name":"admin_has_section-h3","content":"判断是否注入过内容到section，此函数返回一个bool类型值。  var_dump(admin_has_section('navigation'));"},{"h2":"使用","h3":"admin_has_default_section","h4":"","name":"admin_has_default_section-h3","content":"判断是否注入过默认内容到section，此函数返回一个bool类型值。  var_dump(admin_has_default_section('navigation'));"},{"h2":"系统预定义区块","h3":"","h4":"","name":"系统预定义区块-h2","content":"Dcat Admin预定义了一些区块，开发者可以通过这些区块改变页面内容。  所有的预定义区块名称都定义在AdminSection这个类中，通过类常量的方式访问。"},{"h2":"系统预定义区块","h3":"往<head>标签内输入内容","h4":"","name":"往head标签内输入内容-h3","content":"此通过AdminSection::HEAD区块可以往<head>标签内输入内容。  在app\\Admin\\bootstrap.php中加入以下代码：  admin_inject_section(\\AdminSection::HEAD, function () { return '<script src=\"//oss.maxcdn.com/respond/1.4.2/respond.min.js\"></script>'; });"},{"h2":"系统预定义区块","h3":"往<body>标签内输入内容","h4":"","name":"往body标签内输入内容-h3","content":"通过AdminSection::BODY_INNER_BEFORE区块可以往<body>标签内部的开头位置输入内容。  通过AdminSection::BODY_INNER_AFTER区块可以往<body>标签内部的结束位置输入内容。"},{"h2":"系统预定义区块","h3":"往<div id=\"app\">标签内输入内容","h4":"","name":"往dividapp标签内输入内容-h3","content":"通过AdminSection::APP_INNER_BEFORE区块可以往<div id=\"app\">标签内部的开头位置输入内容。  通过AdminSection::APP_INNER_AFTER区块可以往<div id=\"app\">标签内部的结束位置输入内容。"},{"h2":"系统预定义区块","h3":"更改顶部导航栏用户信息面板内容","h4":"","name":"更改顶部导航栏用户信息面板内容-h3","content":"通过AdminSection::NAVBAR_USER_PANEL区块可以更改顶部导航栏的用户信息面板内容。  admin_inject_section(\\AdminSection::NAVBAR_USER_PANEL, view('admin::partials.navbar-user-panel'));"},{"h2":"系统预定义区块","h3":"更改顶部导航栏用户信息面板后面内容","h4":"","name":"更改顶部导航栏用户信息面板后面内容-h3","content":"通过AdminSection::NAVBAR_AFTER_USER_PANEL区块可以更改顶部导航栏的用户信息面板后面的内容。  admin_inject_section(\\AdminSection::NAVBAR_AFTER_USER_PANEL, function () { return <<<HTML <li> <a href=\"#\" data-toggle=\"control-sidebar\"><i class=\"fa fa-gears\"></i></a> </li> HTML; });"},{"h2":"系统预定义区块","h3":"更改菜单栏用户信息面板内容","h4":"","name":"更改菜单栏用户信息面板内容-h3","content":"通过AdminSection::LEFT_SIDEBAR_USER_PANEL区块可以更改菜单栏的用户信息面板的内容。   admin_inject_section(\\AdminSection::LEFT_SIDEBAR_USER_PANEL, view('admin::partials.sidebar-user-panel'));"},{"h2":"系统预定义区块","h3":"更改菜单栏","h4":"","name":"更改菜单栏-h3","content":"通过AdminSection::LEFT_SIDEBAR_MENU可以更改整个菜单栏内容。   Dcat Admin的菜单是通过注入默认内容到LEFT_SIDEBAR_MENU区块而构建的，开发者可以轻易替换掉系统默认的菜单渲染逻辑。   admin_inject_section(\\AdminSection::LEFT_SIDEBAR_MENU, function () { $menuModel = config('admin.database.menu_model'); return $this->build((new $menuModel())->allNodes()); });"}]},{"title":"主题与颜色","link":"theme","nodes":[{"h2":"","h3":"切换主题","h4":"","name":"切换主题-h3","content":"后续版本将会提供更多主题和配色，敬请期待"},{"h2":"","h3":"主题色使用","h4":"","name":"主题色使用-h3","content":"作为日常开发我们离不开颜色的使用，Dcat Admin内置了颜色管理模块，能配合主题切换功能，让页面颜色与主题色相适应！"},{"h2":"","h3":"主题色使用","h4":"颜色样式","name":"颜色样式-h4","content":"Dcat Admin前端页面采用的是bootstrap4编写，因此首先要学习Bootstrap4 颜色(Color)样式的使用，这里不再赘述相关内容。  Dcat Admin自定义颜色样式表"}]},{"title":"多语言","link":"trans","nodes":[{"h2":"","h3":"","h4":"","name":"","content":"在Dcat Admin中使用多语言翻译非常方便，数据表格、数据表单、数据详情和模型树的字段都支持自动读取语言包翻译，具体可参考表格字段翻译、表单字段翻译、数据详情字段翻译。"},{"h2":"语言包文件","h3":"","h4":"","name":"语言包文件-h2","content":"语言包文件类型大概如下  resources/lang ├── ... └── en ├── admin.php # 系统内容语言包，包括菜单标题翻译等都在里面 ├── global.php # 控制器公共语言包 ├── {xxx}.php # 控制器语言包，一个控制器对应一个语言包 └── ...   控制器语言包名称需要与控制器名相对应，例如控制器名UserProfileController，则对应的语言包为resources/lang/{当前语言}/user-profile.php（需要转化为小写中划线风格）。"},{"h2":"控制器语言包内容格式","h3":"","h4":"","name":"控制器语言包内容格式-h2","content":"控制器语言包（包括global.php）中的内容分为三个类别：   fields 数据字段的翻译，这个类别下放置数据字段的翻译 labels 自定义内容翻译，这个类别下是对数据字段外的内容翻译，可以是任何自定义内容 options 枚举选项翻译   下面是例子：  假设控制器语言包user-profile.php内容如下：  <?php return [ 'labels' => [ 'UserProfile' => '用户中心', 'list' => '列表', 'pagination' => [ 'range' => '从 :first 到 :last ，总共 :total 条', ], ], 'fields' => [ 'name' => '名称', 'published' => '发布', 'author' => '作者', 'status' => '状态', ], 'options' => [ 'status' => [ 0 => '未激活', 1 => '已激活', ], ], ];  则语言包可以这么使用  class UserProfileController extend AdminController { public function title() { // labels翻译示例，最终翻译成 “用户中心” return admin_trans_label('UserProfile'); } // fields和options翻译示例 public function grid() { $grid = new Grid(new UserProfile()); // 显示调用语言包翻译，这里会把 “name” 字段翻译成 “名称” $grid->name(admin_trans_field('name')); // 隐式使用语言包翻译，“author” 字段会自动翻译成 “作者” $grid->author; // 调用options翻译 $grid->status()->using(admin_trans('user-profile.options.status')); return $grid; } }"},{"h2":"使用","h3":"admin_trans_field","h4":"","name":"admin_trans_field-h3","content":"这个函数用于翻译fields类别下内容，会自动找对应控制器下的翻译文件，如果翻译不存在会去找global.php中的翻译。  admin_trans_field('name');"},{"h2":"使用","h3":"admin_trans_label","h4":"","name":"admin_trans_label-h3","content":"这个函数用于翻译labels类别下内容，会自动找对应控制器下的翻译文件，如果翻译不存在会去找global.php中的翻译。  admin_trans_label('Posts'); admin_trans_label('pagination.range', ['first' => 1, 'last' => 1, 'total' => 0]);"},{"h2":"使用","h3":"admin_trans_option","h4":"","name":"admin_trans_option-h3","content":"这个函数用于翻译options类别下内容，会自动找对应控制器下的翻译文件，如果翻译不存在会去找global.php中的翻译。  admin_trans_option(1, 'status');"},{"h2":"使用","h3":"admin_trans","h4":"","name":"admin_trans-h3","content":"此方法与Laravel框架自带的trans方法用法没有区别，唯一的区别是：当翻译的内容找不到时，会去global.php中再找一次。  // 先去 user.php 中找 first_name 的翻译，如果找不到会去 global.php 中找 admin_trans('user.first_name');"},{"h2":"公共翻译文件","h3":"","h4":"","name":"公共翻译文件-h2","content":"所有常用的翻译都可以放在resources/lang/{当前语言}/global.php中，当控制器翻译文件不存在时会读取公共翻译文件翻译。  <?php return [ 'fields' => [ 'id' => 'ID', 'name' => '名称', 'username' => '用户名', 'email' => '邮箱', 'password' => '密码', ], 'labels' => [ 'list' => '列表', 'edit' => '编辑', 'detail' => '详细', 'create' => '创建', 'root' => '顶级', 'scaffold' => '代码生成器', ], 'options' => [ ], ];"}]},{"title":"升级注意事项","link":"upgrade","nodes":[]},{"title":"前端组件","link":"widgets","nodes":[{"h2":"Box组件","h3":"","h4":"","name":"Box组件-h2","content":"Dcat\\Admin\\Widgets\\Box用来生成box组件：  use Dcat\\Admin\\Widgets\\Box; $box = new Box('Box标题', 'Box内容'); $box->removable(); $box->collapsable(); $box->style('info'); $box->solid(); echo $box;   Box::__construct($title, $content),$title参数为Box组件的标题，$content参数为Box的内容元素，可以是实现了Illuminate\\Contracts\\Support\\Renderable接口的对象或者其他可打印变量。  Box::title($title)方法用来设置Box组件标题。  Box::content($content)方法用来设置Box组件的内容元素。  Box::removable()方法将Box组件设置为可关闭。  Box::collapsable()方法将Box组件设置为可展开和收起。  Box::style($style)方法设置Box组件的样式，可填值为primary,info,danger,warning,success,default。  Box::solid()方法为Box组件添加边框。"},{"h2":"Collapse组件","h3":"","h4":"","name":"Collapse组件-h2","content":"Dcat\\Admin\\Widgets\\Collapse类用来生成折叠插件：  use Dcat\\Admin\\Widgets\\Collapse; $collapse = new Collapse(); $collapse->add('Bar', 'xxxxx'); $collapse->add('Orders', new Table()); echo $collapse->render();   Collapse::add($title, $content)方法用来给折叠组件添加一个折叠项，$title参数设置该折叠项的标题，$content参数用来舍子折叠区的内用。"},{"h2":"表单","h3":"","h4":"","name":"表单-h2","content":"Dcat\\Admin\\Widgets\\Form类用来快速构建表单：   $form = new Form(); $form->action('example'); $form->email('email')->default('qwe@aweq.com'); $form->password('password'); $form->text('name', '输入框'); $form->url('url'); $form->color('color'); $form->map('lat', 'lng'); $form->date('date'); $form->json('val'); $form->dateRange('created_at', 'updated_at'); echo $form->render();  Form::__construct($data = [])生成一个form对象，如果传入了$data参数，$data数组中的元素将会按照key对应填入form对应name的表单中。  Form::action($uri)方法用来设置表单提交地址。  Form::method($method)方法用来设置form表单的提交方法,默认为POST方法。  Form::disablePjax() 不使用pjax方式提交表单。"},{"h2":"Infobox组件","h3":"","h4":"","name":"Infobox组件-h2","content":"Dcat\\Admin\\Widgets\\InfoBox类用来生成信息展示块：  use Dcat\\Admin\\Widgets\\InfoBox; $infoBox = new InfoBox('New Users', 'users', 'aqua', '/admin/users', '1024'); echo $infoBox->render();   效果请参考后台首页的布局文件HomeController.php的index()方法中，关于InfoBox的部分。"},{"h2":"Tab组件","h3":"","h4":"","name":"Tab组件-h2","content":"Dcat\\Admin\\Widgets\\Tab类用来生成选项卡组件：  use Dcat\\Admin\\Widgets\\Tab; $tab = new Tab(); $tab->add('Pie', $pie); $tab->add('Table', new Table()); $tab->add('Text', 'blablablabla....'); echo $tab->render();   Tab::add($title, $content)方法用来添加一个选项卡，$title为选项标题，$content选项卡内容。"},{"h2":"Table","h3":"","h4":"","name":"Table-h2","content":"Dcat\\Admin\\Widgets\\Table类用来生成表格：  use Dcat\\Admin\\Widgets\\Table; // table 1 $headers = ['Id', 'Email', 'Name', 'Company']; $rows = [ [1, 'labore21@yahoo.com', 'Ms. Clotilde Gibson', 'Goodwin-Watsica'], [2, 'omnis.in@hotmail.com', 'Allie Kuhic', 'Murphy, Koepp and Morar'], [3, 'quia65@hotmail.com', 'Prof. Drew Heller', 'Kihn LLC'], [4, 'xet@yahoo.com', 'William Koss', 'Becker-Raynor'], [5, 'ipsa.aut@gmail.com', 'Ms. Antonietta Kozey Jr.'], ]; $table = new Table($headers, $rows); echo $table->render(); // table 2 $headers = ['Keys', 'Values']; $rows = [ 'name' => 'Joe', 'age' => 25, 'gender' => 'Male', 'birth' => '1989-12-05', ]; $table = new Table($headers, $rows); echo $table->render(); "}]}]